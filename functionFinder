<?php
/**
 * CLI: php scan.php <TARGET_DIR> [<OUTFILE>]
 * 依存   : nikic/php-parser, phpoffice/phpspreadsheet
 * PHP推奨: 8.1+
 */

declare(strict_types=1);

require_once __DIR__ . '/vendor/autoload.php';

use PhpParser\{Error, Node, NodeTraverser, NodeVisitorAbstract, ParserFactory, NodeFinder};
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;

/* ---------- 引数チェック ---------- */
if (($target = $argv[1] ?? null) === null) {
    fwrite(STDERR, "Usage: php scan.php <TARGET_DIR> [<OUTFILE>]\n");
    exit(1);
}
$targetDir = realpath($target);
if ($targetDir === false || !is_dir($targetDir)) {
    fwrite(STDERR, "Error: '{$target}' is not a directory.\n");
    exit(1);
}
$outFile = $argv[2] ?? 'functions.xlsx';

/* ---------- ヘルパー ---------- */
final class PhpCleaner
{
    /** 開始タグ補完 : ファイル内に `<?` が 1 つも無ければ先頭に挿入 */
    public static function completeStartTag(string $code): string
    {
        return str_contains($code, '<?')
            ? $code
            : "<?php\n" . $code;
    }

    /** コメント除去 : TOKEN_PARSE は **付けない** ＝ 構文チェックしない */
    public static function stripComments(string $code): string
    {
        $out = '';
        foreach (token_get_all($code) as $tok) {
            if (is_array($tok)) {
                [$id, $text] = $tok;
                if (in_array($id, [T_COMMENT, T_DOC_COMMENT], true)) continue;
                $out .= $text;
            } else {
                $out .= $tok;
            }
        }
        return $out;
    }
}

/* ---------- SQL を含む関数抽出ビジター ---------- */
final class FuncVisitor extends NodeVisitorAbstract
{
    /** @var array<int,array{file:string,func:string,calls:array<int,string>}> */
    public array $functions = [];

    private ?string $current = null;
    private string  $file;
    /** @var array<string,array<int,string>> 呼び出し記録 */
    private array $callsMap = [];

    public function __construct(string $file) { $this->file = $file; }

    public function enterNode(Node $n)
    {
        if ($n instanceof Node\Stmt\Function_ || $n instanceof Node\Stmt\ClassMethod) {
            $name = $n instanceof Node\Stmt\ClassMethod
                ? ($n->getAttribute('parent')?->namespacedName ?? 'AnonymousClass') . '::' . $n->name
                : (string)$n->name;

            // スタック
            $n->setAttribute('prev', $this->current);
            $this->current = $name;
        }

        // 関数呼び出し収集
        if ($this->current && $n instanceof Node\Expr\FuncCall) {
            $called = $n->name instanceof Node\Name ? $n->name->toString() : '(dynamic)';
            $this->callsMap[$this->current][] = $called;
        }
    }

    public function leaveNode(Node $n)
    {
        if ($n instanceof Node\Stmt\Function_ || $n instanceof Node\Stmt\ClassMethod) {
            $name = $this->current;
            if ($this->containsSql($n)) {
                $this->functions[] = [
                    'file'  => $this->file,
                    'func'  => $name,
                    'calls' => array_values(array_unique($this->callsMap[$name] ?? [])),
                ];
            }
            // スタック戻し
            $this->current = $n->getAttribute('prev');
        }
    }

    /** NodeFinder で文字列リテラル検索 → SQL キーワード判定 */
    private function containsSql(Node\FunctionLike $fn): bool
    {
        $finder = new NodeFinder();
        $strings = $finder->findInstanceOf($fn->getStmts() ?? [], Node\Scalar\String_::class);

        $re = '/\b(SELECT|INSERT|UPDATE|DELETE|REPLACE|WITH|MERGE)\b/i';
        foreach ($strings as $s) {
            if (preg_match($re, $s->value)) {
                return true;
            }
        }
        return false;
    }
}

/* ---------- 解析ループ ---------- */
$parser = (new ParserFactory())->createForNewestSupportedVersion();
$rii    = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator(
                $targetDir,
                RecursiveDirectoryIterator::SKIP_DOTS | RecursiveDirectoryIterator::FOLLOW_SYMLINKS));

$results = [];   // SQL を含む関数
$errors  = [];   // パース不能ファイル

foreach ($rii as $info) {
    if (!$info->isFile()) continue;
    if (!preg_match('/\.(php|inc)$/i', $info->getFilename())) continue;

    $code = file_get_contents($info->getPathname());
    if ($code === false) continue;

    $clean = PhpCleaner::stripComments(
                PhpCleaner::completeStartTag($code));

    try {
        $ast = $parser->parse($clean);
    } catch (Error $e) {
        $errors[] = ['file'=>$info->getPathname(), 'msg'=>$e->getMessage()];
        fwrite(STDERR, "[WARN] parse error: {$info->getPathname()}\n");
        continue;
    }

    $trav = new NodeTraverser();
    $vis  = new FuncVisitor($info->getPathname());
    $trav->addVisitor($vis);
    $trav->traverse($ast);

    $results = array_merge($results, $vis->functions);
}

/* ---------- Excel 出力 ---------- */
$book = new Spreadsheet();

/* Functions シート */
$funcSheet = $book->getActiveSheet();
$funcSheet->setTitle('Functions with SQL');
$funcSheet->fromArray(['ファイル名','関数名','呼んでいる関数'], null, 'A1');

$r = 2;
foreach ($results as $row) {
    $funcSheet->setCellValue("A{$r}", $row['file']);
    $funcSheet->setCellValue("B{$r}", $row['func']);
    $funcSheet->setCellValue("C{$r}", implode(', ', $row['calls']));
    ++$r;
}
foreach (range('A','C') as $c) $funcSheet->getColumnDimension($c)->setAutoSize(true);

/* Log シート */
$log = $book->createSheet();
$log->setTitle('Log');
$log->fromArray(['ファイル名','エラーメッセージ'], null, 'A1');
$r = 2;
foreach ($errors as $e) {
    $log->setCellValue("A{$r}", $e['file']);
    $log->setCellValue("B{$r}", $e['msg']);
    ++$r;
}
foreach (range('A','B') as $c) $log->getColumnDimension($c)->setAutoSize(true);

/* 保存 */
(new Xlsx($book))->save($outFile);
echo "Done → {$outFile}\n";