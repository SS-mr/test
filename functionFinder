<?php
/**
 * CLI: php scan.php <TARGET_DIR> [<OUTFILE>]
 *
 * 依存   : nikic/php-parser, phpoffice/phpspreadsheet
 * PHP推奨: 8.1+
 */

declare(strict_types=1);

require_once __DIR__ . '/vendor/autoload.php';

use PhpParser\{Error, Node, NodeTraverser, NodeVisitorAbstract, ParserFactory};
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;

/* ---------- 1. 引数チェック ---------- */
if (($target = $argv[1] ?? null) === null) {
    fwrite(STDERR, "Usage: php scan.php <TARGET_DIR> [<OUTFILE>]\n");
    exit(1);
}
$targetDir = realpath($target);
if ($targetDir === false || !is_dir($targetDir)) {
    fwrite(STDERR, "Error: '{$target}' is not a directory.\n");
    exit(1);
}
$outFile = $argv[2] ?? 'functions.xlsx';

/* ---------- 2. ヘルパークラス ---------- */
final class PhpCleaner
{
    /** 開始タグ補完 */
    public static function completeStartTag(string $code): string
    {
        $trimmed = ltrim($code);
        if (str_starts_with($trimmed, '<?php')) return $code;
        if (str_starts_with($trimmed, '<?'))    return preg_replace('/^<\?/', '<?php', $code, 1);
        return "<?php\n" . $code;
    }
    /** コメント除去 */
    public static function stripComments(string $code): string
    {
        $out = '';
        foreach (token_get_all($code, TOKEN_PARSE) as $t) {
            if (is_array($t)) {
                [$id, $text] = $t;
                if (in_array($id, [T_COMMENT, T_DOC_COMMENT], true)) continue;
                $out .= $text;
            } else {
                $out .= $t;
            }
        }
        return $out;
    }
}

/* ---------- 3. AST ビジター ---------- */
final class FuncVisitor extends NodeVisitorAbstract
{
    /** @var array<int,array{file:string,func:string,calls:array<int,string>}> */
    public array $functions = [];
    /** @var array<string,Node\FunctionLike> */
    private array $funcBodies = [];
    private ?string $currentFunc = null;
    private string $file;

    public function __construct(string $file) { $this->file = $file; }

    public function enterNode(Node $node)
    {
        if ($node instanceof Node\Stmt\Function_ || $node instanceof Node\Stmt\ClassMethod) {
            $funcName = $node instanceof Node\Stmt\ClassMethod
                ? ($node->getAttribute('parent')?->name->toString() ?? 'AnonymousClass') . '::' . $node->name->toString()
                : $node->name->toString();

            $prev = $this->currentFunc;
            $this->currentFunc = $funcName;
            $node->setAttribute('prevFunc', $prev);
            $this->funcBodies[$funcName] = $node;
        }

        if ($this->currentFunc && $node instanceof Node\Expr\FuncCall) {
            $called = $node->name instanceof Node\Name ? $node->name->toString() : '(dynamic)';
            $body   = $this->funcBodies[$this->currentFunc];
            $calls  = $body->getAttribute('calls') ?? [];
            $calls[] = $called;
            $body->setAttribute('calls', $calls);
        }
    }

    public function leaveNode(Node $node)
    {
        if ($node instanceof Node\Stmt\Function_ || $node instanceof Node\Stmt\ClassMethod) {
            if ($this->hasSql($node)) {
                $this->functions[] = [
                    'file'  => $this->file,
                    'func'  => $this->currentFunc,
                    'calls' => array_values(array_unique($node->getAttribute('calls') ?? [])),
                ];
            }
            $this->currentFunc = $node->getAttribute('prevFunc');
        }
    }

    private function hasSql(Node\FunctionLike $func): bool
    {
        $found = false;
        $re = '/\b(SELECT|INSERT|UPDATE|DELETE|REPLACE|WITH|MERGE)\b/i';
        $sub = new NodeTraverser();
        $sub->addVisitor(new class($found, $re) extends NodeVisitorAbstract {
            private string $re; private bool $found;
            public function __construct(bool &$found, string $re) { $this->found = &$found; $this->re = $re; }
            public function enterNode(Node $n)
            {
                if ($n instanceof Node\Scalar\String_ && preg_match($this->re, $n->value)) {
                    $this->found = true;
                    return NodeTraverser::STOP_TRAVERSAL;
                }
            }
        });
        $sub->traverse($func->getStmts() ?? []);
        return $found;
    }
}

/* ---------- 4. 解析実行 ---------- */
$parser  = (new ParserFactory())->createForNewestSupportedVersion();
$rii     = new RecursiveIteratorIterator(
             new RecursiveDirectoryIterator(
                 $targetDir,
                 RecursiveDirectoryIterator::SKIP_DOTS | RecursiveDirectoryIterator::FOLLOW_SYMLINKS
             ));
$results = [];            // 関数解析結果
$errors  = [];            // パースエラー結果

foreach ($rii as $info) {
    if (!$info->isFile()) continue;
    $path = $info->getPathname();
    if (!preg_match('/\.(php|inc)$/i', $path)) continue;

    $code = file_get_contents($path);
    if ($code === false) continue;

    $clean = PhpCleaner::stripComments(
                 PhpCleaner::completeStartTag($code)
             );

    try {
        $ast = $parser->parse($clean);
    } catch (Error $e) {
        // ログへ追加して次のファイルへ
        $errors[] = ['file' => $path, 'msg' => $e->getMessage()];
        fwrite(STDERR, "[WARN] Parse error in {$path}\n");
        continue;
    }

    $trav = new NodeTraverser();
    $vis  = new FuncVisitor($path);
    $trav->addVisitor($vis);
    $trav->traverse($ast);

    $results = array_merge($results, $vis->functions);
}

/* ---------- 5. Excel 出力 ---------- */
$book = new Spreadsheet();

/* 5-1. Functions シート */
$funcSheet = $book->getActiveSheet();
$funcSheet->setTitle('Functions with SQL');
$funcSheet->fromArray(['ファイル名','関数名','呼んでいる関数'], null, 'A1');

$r = 2;
foreach ($results as $row) {
    $funcSheet->setCellValue("A{$r}", $row['file']);
    $funcSheet->setCellValue("B{$r}", $row['func']);
    $funcSheet->setCellValue("C{$r}", implode(', ', $row['calls']));
    ++$r;
}
foreach (range('A','C') as $col) $funcSheet->getColumnDimension($col)->setAutoSize(true);

/* 5-2. Log シート（パースエラー） */
$logSheet = $book->createSheet();
$logSheet->setTitle('Log');
$logSheet->fromArray(['ファイル名','エラーメッセージ'], null, 'A1');

$r = 2;
foreach ($errors as $err) {
    $logSheet->setCellValue("A{$r}", $err['file']);
    $logSheet->setCellValue("B{$r}", $err['msg']);
    ++$r;
}
foreach (range('A','B') as $col) $logSheet->getColumnDimension($col)->setAutoSize(true);

/* 保存 */
(new Xlsx($book))->save($outFile);
echo "Done! Results: {$outFile}\n";