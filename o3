#!/usr/bin/env php
<?php
/**
 * crud-analyzer.php  –  File-CRUD 図ジェネレータ
 * -----------------------------------------------------------------
 *  ○ include/require 再帰（循環検知）
 *  ○ 変数・定数・複雑式 静的評価（多値対応）
 *  ○ ユーザー関数テーブル＋束縛付き再帰評価
 *  ○ エイリアス / JOIN / サブクエリ / WITH(CTE) / SELECT … INTO TEMP
 *  ○ CREATE TEMP / DROP / TRUNCATE / ON CONFLICT
 *  ○ “同じ変数に複数 SQL” も候補すべて CRUD OR
 *  ○ AST が読めないファイルは正規表現フォールバック
 *  ○ コメント除去 → AST サイズ縮小
 *  ○ 一時配列 shrink() で解放 → メモリ節約
 *  ○ PhpSpreadsheet を GZIP キャッシュ
 *  ○ Excel (File-CRUD.xlsx) & Log.txt 出力
 * -----------------------------------------------------------------
 *  2025-04-30   MIT-0   by ChatGPT o3
 */

declare(strict_types=1);
date_default_timezone_set('Asia/Tokyo');
error_reporting(E_ALL);

/*─────────────────────────── 依存 ───────────────────────────*/
require __DIR__ . '/vendor/autoload.php';
use PhpParser\{Error as PhpParserError, Node, NodeTraverser,
               NodeVisitorAbstract, ParserFactory};
use PHPSQLParser\PHPSQLParser;
use PhpOffice\PhpSpreadsheet\{Spreadsheet, Writer\Xlsx, Settings};

/*──────────────────── ランタイム／キャッシュ設定 ─────────────*/
ini_set('memory_limit', '1024M');       // 必要に応じて調整 or -1
gc_enable();                            // GC を確実に有効化
Settings::setCache(Settings::CACHE_MEMORY_GZIP);  // Excel セルを GZIP

/*──────────────────── 定数 & ヘルパ ────────────────────────*/
const UNCERTAIN      = '⚠不明';
const EXT            = ['php','inc'];
const MAX_INCLUDE    = 50;              // include/require 再帰上限
const MAX_FUNC_DEPTH = 5;               // 関数呼び出し再帰上限
const MAX_CANDIDATES = 32;              // 多値爆発抑制（超過で UNCERTAIN）

/** コメントを簡易除去（文字列内は考慮しない） */
function stripComments(string $code): string
{
    $code=preg_replace('~/\*.*?\*/~s','',$code);   // /**/ ブロック
    $code=preg_replace('~//.*$~m','',$code);       // // 行
    $code=preg_replace('~#.*$~m','',$code);        // # 行
    return $code;
}

/** デカルト積ユーティリティ */
function cartesian(array $arrays): array
{
    $res=[[]];
    foreach($arrays as $a){
        $tmp=[];
        foreach($res as $p) foreach($a as $v) $tmp[]=[...$p,$v];
        $res=$tmp;
    }
    return $res;
}

/*──────────────────── データモデル ─────────────────────────*/
class CrudFlags{public bool $c=false,$r=false,$u=false,$d=false;}

class FunctionDef{
    public function __construct(
        public string $name,
        public array  $params,       // [ '$param' => defaultCandidates[] ]
        public Node\Stmt\Function_ $body
    ){}
}

class FileContext{
    public function __construct(public string $path){}
    /** @var array<string,string[]> */ public array $variables=[];
    /** @var string[]                 */ public array $sqlCandidates=[];
    /** @var array<string,CrudFlags>  */ public array $crud=[];
    /** @var string[]                 */ public array $tempTables=[];

    /** 解析後に重い一時配列を解放してメモリ回収 */
    public function shrink(): void
    {
        $this->variables=$this->sqlCandidates=$this->tempTables=[];
        gc_collect_cycles();
    }
}

class Project{
    /** @var array<string,FileContext> */ public array $files=[];
    /** @var array<string,FunctionDef> */ public array $funcDefs=[];
    public array $log=[];
    function addLog(string $m){$this->log[]=date('[H:i:s] ').$m;}
}

/*──────────────── ExpressionEvaluator ────────────────*/
class ExpressionEvaluator
{
    public function __construct(
        private FileContext $ctx,
        private array $locals=[],
        private int   $depth=0
    ){}
    /** @return string[]|null */
    public function eval(Node $n): ?array
    {
        if($this->depth>MAX_FUNC_DEPTH) return [UNCERTAIN];

        /* 1) 文字列リテラル */
        if($n instanceof Node\Scalar\String_) return [$n->value];

        /* 2) Encapsed / ヒアドック */
        if($n instanceof Node\Scalar\Encapsed){
            $out=[''];
            foreach($n->parts as $p){
                $seg=$this->rec($p)??[UNCERTAIN]; $tmp=[];
                foreach($out as $b)foreach($seg as $s)$tmp[]=$b.$s;
                $out=$tmp;
            }
            return array_slice(array_unique($out),0,MAX_CANDIDATES);
        }

        /* 3) 変数 */
        if($n instanceof Node\Expr\Variable && is_string($n->name))
            return $this->locals['$'.$n->name]??$this->ctx->variables['$'.$n->name]??null;

        /* 4) '.' 連結 */
        if($n instanceof Node\Expr\BinaryOp\Concat)
            return $this->cross($n->left,$n->right,fn($a,$b)=>$a.$b);

        /* 5) 算術 (+ - * / %) → 文字列 */
        if($n instanceof Node\Expr\BinaryOp
           && method_exists($n,'getOperatorSigil')
           && in_array($n->getOperatorSigil(),['+','-','*','/','%'],true))
            return $this->cross(
                $n->left,$n->right,
                fn($a,$b)=>is_numeric($a)&&is_numeric($b)
                    ? (string)eval("return {$a}{$n->getOperatorSigil()}{$b};")
                    : UNCERTAIN
            );

        /* 6) 三項演算子 */
        if($n instanceof Node\Expr\Ternary)
            return array_slice(array_unique([
                ...($this->rec($n->if ?? $n->cond)??[UNCERTAIN]),
                ...($this->rec($n->else)??[UNCERTAIN])
            ]),0,MAX_CANDIDATES);

        /* 7) Null 合体 */
        if($n instanceof Node\Expr\BinaryOp\Coalesce)
            return array_slice(array_unique([
                ...($this->rec($n->left)??[UNCERTAIN]),
                ...($this->rec($n->right)??[UNCERTAIN])
            ]),0,MAX_CANDIDATES);

        /* 8) sprintf / implode / join */
        if($n instanceof Node\Expr\FuncCall && $n->name instanceof Node\Name){
            $fn=strtolower((string)$n->name);
            if(in_array($fn,['sprintf','vsprintf'])){
                $fmt=$this->rec($n->args[0]->value)??[UNCERTAIN];
                $sets=[]; for($i=1;$i<count($n->args);$i++) $sets[]=$this->rec($n->args[$i]->value)??[UNCERTAIN];
                $out=[]; foreach($fmt as $f) foreach(cartesian($sets) as $s) $out[]=vsprintf($f,$s);
                return array_slice(array_unique($out),0,MAX_CANDIDATES);
            }
            if(in_array($fn,['implode','join'])&&count($n->args)===2){
                $g=$this->rec($n->args[0]->value)[0]??','; $arr=$this->rec($n->args[1]->value);
                if($arr&&!in_array(UNCERTAIN,$arr,true)) return [$g.implode($g,$arr)];
            }
        }
        return null;
    }
    private function rec(Node $n):?array{return(new self($this->ctx,$this->locals,$this->depth+1))->eval($n);}
    private function cross(Node $l,Node $r,callable $f):array{
        $a=$this->rec($l)??[UNCERTAIN]; $b=$this->rec($r)??[UNCERTAIN]; $o=[];
        foreach($a as $x)foreach($b as $y){
            $o[]=$f($x,$y);
            if(count($o)>=MAX_CANDIDATES){$o[]=UNCERTAIN;break 2;}
        }
        return array_unique($o);
    }
}

/*──────────────── Visitor: 関数定義収集 ─────────────────*/
class FunctionCollectVisitor extends NodeVisitorAbstract
{
    public function __construct(private Project $proj,private string $file){}
    public function enterNode(Node $n):null|int|Node{
        if(!$n instanceof Node\Stmt\Function_) return null;
        $params=[];
        foreach($n->getParams() as $p){
            $def=$p->default?(new ExpressionEvaluator($this->proj->files[$this->file]))->eval($p->default):[UNCERTAIN];
            $params['$'.$p->var->name]=$def;
        }
        $this->proj->funcDefs[(string)$n->name]=new FunctionDef((string)$n->name,$params,$n);
        return null;
    }
}

/*──────────────── Visitor: 変数代入 / 結合 ─────────────────*/
class EvaluateVisitor extends NodeVisitorAbstract
{
    private ExpressionEvaluator $ev;
    public function __construct(private FileContext $ctx,private Project $proj,private array $locals=[]) {}
    public function beforeTraverse(array $n){$this->ev=new ExpressionEvaluator($this->ctx,$this->locals);}
    public function enterNode(Node $n):null|int|Node
    {
        if($n instanceof Node\Expr\Assign && $n->var instanceof Node\Expr\Variable && is_string($n->var->name)){
            $name='$'.$n->var->name; $vals=$this->ev->eval($n->expr)??[UNCERTAIN];
            $this->ctx->variables[$name]=array_slice(array_unique([...($this->ctx->variables[$name]??[]), ...$vals]),0,MAX_CANDIDATES);
        }
        if($n instanceof Node\Expr\AssignOp\Concat && $n->var instanceof Node\Expr\Variable && is_string($n->var->name)){
            $name='$'.$n->var->name; $add=$this->ev->eval($n->expr)??[UNCERTAIN];
            $base=$this->ctx->variables[$name]??[UNCERTAIN]; $new=[];
            foreach($base as $b)foreach($add as $a)$new[]=($b===UNCERTAIN||$a===UNCERTAIN)?UNCERTAIN:$b.$a;
            $this->ctx->variables[$name]=array_slice(array_unique([...$base,...$add,...$new]),0,MAX_CANDIDATES);
        }
        return null;
    }
}

/*──────────────── Visitor: SQL 抽出 & 関数再帰 ───────────────*/
class SqlCallVisitor extends NodeVisitorAbstract
{
    public function __construct(private FileContext $ctx,private Project $proj,private array $locals=[]) {}
    private ExpressionEvaluator $ev;
    public function beforeTraverse(array $n){$this->ev=new ExpressionEvaluator($this->ctx,$this->locals);}
    public function enterNode(Node $n):null|int|Node
    {
        if(!$n instanceof Node\Expr\FuncCall||!$n->name instanceof Node\Name) return null;
        $fname=(string)$n->name;

        /* ユーザー関数再帰 */
        if(isset($this->proj->funcDefs[$fname])){
            $def=$this->proj->funcDefs[$fname]; $bind=[];
            foreach($def->params as $i=>$pname){
                $arg=$n->args[$i]->value ?? null;
                $bind[$pname]=$arg?($this->ev->eval($arg)??[UNCERTAIN]):$def->params[$pname];
            }
            if(($this->locals['_depth']??0)<MAX_FUNC_DEPTH){
                $loc=[...$bind,'_depth'=>($this->locals['_depth']??0)+1];
                $tr=new NodeTraverser();
                $tr->addVisitor(new EvaluateVisitor($this->ctx,$this->proj,$loc));
                $tr->addVisitor(new self($this->ctx,$this->proj,$loc));
                $tr->traverse($def->body->stmts);
            }
        }

        /* SQL 実行系 */
        $lower=strtolower($fname);
        if(in_array($lower,['pg_query','query','exec','pg_prepare','pg_send_query','pg_execute'])){
            $arg=end($n->args)->value ?? null;
            $vals=$arg?($this->ev->eval($arg)??[UNCERTAIN]):[UNCERTAIN];
            $this->ctx->sqlCandidates=array_slice(array_unique([...$this->ctx->sqlCandidates,...$vals]),0,MAX_CANDIDATES);
        }
        return null;
    }
}

/*──────────────── FROM 句→テーブル抽出 ───────────────────*/
function tablesFrom(array $clause): array
{
    $tbls=[];
    foreach($clause as $c){
        if(($c['expr_type']??'')==='table')                $tbls[]=$c['table'];
        if(isset($c['join_type'])&&isset($c['table']))     $tbls[]=$c['table'];
        if(($c['expr_type']??'')==='subquery' && isset($c['sub_tree']))
            $tbls=array_merge($tbls,tablesFrom($c['sub_tree']['FROM']??[]));
    }
    return $tbls;
}

/*──────────────── サブクエリ再帰 ─────────────────────────*/
function analyzeCrudSubTree(array $sub,array $views,array $procs,FileContext $ctx): array
{
    $sql=$sub['raw'] ?? null;
    return $sql ? analyzeCrud($sql,$views,$procs,$ctx) : [];
}

/*──────────────── SQL → CRUD 判定 ───────────────────────*/
function analyzeCrud(string $sql,array $views,array $procs,FileContext $ctx): array
{
    if($sql===UNCERTAIN) return [];
    try{$tree=(new PHPSQLParser($sql,true))->parsed;}catch(\Throwable){return [];}

    $r=[];
    $add=function(string $tbl,string $flag)use(&$r){
        $r[$tbl]??=new CrudFlags(); $r[$tbl]->$flag=true;
    };
    $tag=function($t)use($views,$procs){
        return in_array($t,$views)?$t.'@view'
             :(in_array($t,$procs)?$t.'@proc':$t);
    };
    $stmt=strtoupper(array_key_first($tree)??'');
    /* WITH 句 (CTE) */
    if(isset($tree['WITH']['subqueries'])){
        foreach($tree['WITH']['subqueries'] as $cte){
            $n=$cte['alias']['name']??null;
            if($n){$add($n.'@temp','c'); $ctx->tempTables[]=$n;}
            if(isset($cte['sub_tree'])){
                foreach(analyzeCrudSubTree($cte['sub_tree'],$views,$procs,$ctx) as $t=>$f){
                    $r[$t]??=new CrudFlags();
                    foreach(['c','r','u','d'] as $k) $r[$t]->$k|=$f->$k;
                }
            }
        }
    }

    /* ステートメント種別 */
    switch($stmt){
        /* FROM 句すべて R + TEMP の読取も R */
        case'WITH':case'SELECT':case'UPDATE':case'DELETE':case'INSERT':
            foreach(tablesFrom($tree['FROM']??[]) as $t){
                $tbl=in_array($t,$ctx->tempTables,true)?$t.'@temp':$tag($t);
                $add($tbl,'r');
            }
            /* SELECT … INTO TEMP */
            if(isset($tree['INTO'])){
                foreach($tree['INTO'] as $in)
                    if(($in['expr_type']??'')==='table'){
                        $add($in['table'].'@temp','c');
                        $ctx->tempTables[]=$in['table'];
                    }
            }
            break;

        /* INSERT → C (+U if ON CONFLICT) */
        case'INSERT':
            $tbl=$tree['INSERT'][0]['table']??null;
            if($tbl){
                $add($tag($tbl),'c');
                if(isset($tree['ONCONFLICT'])) $add($tag($tbl),'u');
            }
            break;

        /* UPDATE → U */
        case'UPDATE':
            if(isset($tree['UPDATE'][0]['table'])) $add($tag($tree['UPDATE'][0]['table']),'u');
            break;

        /* DELETE/TRUNCATE → D */
        case'DELETE':case'TRUNCATE':
            foreach(($tree[$stmt]??[]) as $x) if(isset($x['table'])) $add($tag($x['table']),'d');
            break;

        /* DROP → R（参照破棄として） */
        case'DROP':
            if(isset($tree['TABLE'][0]['table'])) $add($tag($tree['TABLE'][0]['table']),'r');
            break;

        /* CREATE TEMP TABLE → C */
        case'CREATE':
            if(isset($tree['TABLE']['no_quotes']['parts'][0])){
                $t=$tree['TABLE']['no_quotes']['parts'][0];
                $add($t.'@temp','c'); $ctx->tempTables[]=$t;
            }
            break;
    }
    return $r;
}

/*──────────────── フォールバック (正規表現) ───────────────*/
function fallbackParse(string $code,FileContext $ctx): void
{
    $code=stripComments($code);

    /* 変数 = / .= 抽出 */
    if(preg_match_all('/\$(\w+)\s*(=|\.=)\s*(.+?);/s',$code,$m,PREG_SET_ORDER)){
        foreach($m as [$all,$var,$op,$expr]){
            $parser=(new ParserFactory)->createForNewestSupportedVersion();
            try{$ast=$parser->parse('<?php '.$expr.';')[0]->expr??null;}catch(\Throwable){$ast=null;}
            $vals=$ast?(new ExpressionEvaluator($ctx))->eval($ast):[UNCERTAIN];
            $name='$'.$var;
            if($op==='='){
                $ctx->variables[$name]=$vals;
            }else{
                $base=$ctx->variables[$name]??[UNCERTAIN]; $new=[];
                foreach($base as $b)foreach($vals as $v)
                    $new[]=($b===UNCERTAIN||$v===UNCERTAIN)?UNCERTAIN:$b.$v;
                $ctx->variables[$name]=array_slice(array_unique([...$base,...$vals,...$new]),0,MAX_CANDIDATES);
            }
        }
    }

    /* SQL 実行呼び出し */
    if(preg_match_all('/\b(pg_query|query|exec|pg_prepare|pg_send_query)\s*\(([^;]*?)\);/i',$code,$m,PREG_SET_ORDER)){
        foreach($m as $row){
            $arg=trim(end(explode(',',$row[2])));
            if(preg_match('/^[\'"](.+)[\'"]$/s',$arg,$mm)){
                $ctx->sqlCandidates[]=$mm[1];
            }elseif(preg_match('/^\$(\w+)$/',$arg,$mm)){
                $ctx->sqlCandidates=array_merge($ctx->sqlCandidates,$ctx->variables['$'.$mm[1]]??[UNCERTAIN]);
            }else $ctx->sqlCandidates[]=UNCERTAIN;
        }
    }

    /* DROP / TRUNCATE / SELECT … INTO TEMP を直接検出 */
    if(preg_match_all('~\b(SELECT.+?INTO\s+TEMP\s+\w+|TRUNCATE\s+TABLE\s+\w+|DROP\s+TABLE\s+\w+)~is',$code,$mm))
        $ctx->sqlCandidates=array_merge($ctx->sqlCandidates,$mm[0]);
}

/*──────────────── 走査ユーティリティ ─────────────────────*/
function scan(string $dir):array{
    $it=new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir,FilesystemIterator::SKIP_DOTS));
    $out=[]; foreach($it as $f) if(in_array(strtolower($f->getExtension()),EXT,true)) $out[]=$f->getRealPath();
    return $out;
}
function detectIncludes(string $code,string $base):array{
    $out=[]; $code=stripComments($code);
    if(preg_match_all('/\b(include|require)(_once)?\s*\(?\s*[\'"]([^\'"]+)["\']\s*\)?\s*;/i',$code,$m,PREG_SET_ORDER))
        foreach($m as $row) if(($abs=realpath($base.'/'.$row[3]))) $out[]=$abs;
    return $out;
}

/*──────────────── Pass-0: 関数定義収集 ───────────────────*/
function collectFunctions(Project $p):void{
    foreach($p->files as $ctx){
        $code=@file_get_contents($ctx->path); if($code===false)continue;
        $code=stripComments($code);
        try{$ast=(new ParserFactory)->createForNewestSupportedVersion()->parse($code);}catch(\Throwable){continue;}
        $tr=new NodeTraverser(); $tr->addVisitor(new FunctionCollectVisitor($p,$ctx->path)); $tr->traverse($ast);
    }
}

/*──────────────── Pass-1: 本解析 ─────────────────────────*/
function analyzeFile(string $abs,Project $proj,array $views,array $procs,int $depth=0):void
{
    if($proj->files[$abs]??false || $depth>MAX_INCLUDE) return;
    $code=@file_get_contents($abs); if($code===false)return;
    $ctx=new FileContext($abs); $proj->files[$abs]=$ctx;

    foreach(detectIncludes($code,dirname($abs)) as $inc)
        analyzeFile($inc,$proj,$views,$procs,$depth+1);

    $parser=(new ParserFactory)->createForNewestSupportedVersion();
    try{$ast=$parser->parse(stripComments($code));}
    catch(PhpParserError $e){
        $proj->addLog("AST ERROR {$abs}: ".$e->getMessage());
        fallbackParse($code,$ctx); goto crud;
    }

    $tr=new NodeTraverser();
    $tr->addVisitor(new EvaluateVisitor($ctx,$proj));
    $tr->addVisitor(new SqlCallVisitor($ctx,$proj));
    $tr->traverse($ast);

    /* 変数名に 'sql' を含む候補も SQL とみなす */
    foreach($ctx->variables as $n=>$vals)
        if(stripos($n,'sql')!==false)
            $ctx->sqlCandidates=array_slice(array_unique([...$ctx->sqlCandidates,...$vals]),0,MAX_CANDIDATES);

crud:
    foreach($ctx->sqlCandidates as $sql)
        foreach(analyzeCrud($sql,$views,$procs,$ctx) as $tbl=>$f){
            $ctx->crud[$tbl]??=new CrudFlags();
            foreach(['c','r','u','d'] as $k) $ctx->crud[$tbl]->$k|=$f->$k;
        }

    /* 一時配列を解放 */
    $ctx->shrink();
}

/*──────────────── Excel & Log 出力 ───────────────────────*/
function exportExcel(Project $proj,string $file):void
{
    $s=new Spreadsheet(); $sh=$s->getActiveSheet(); $sh->setTitle('File-CRUD');
    $sh->fromArray(['File','Table','C','R','U','D','⚠不明?']);
    $row=2;
    foreach($proj->files as $ctx){
        if($ctx->crud===[]) continue;
        $unc=in_array(UNCERTAIN,$ctx->sqlCandidates,true)?'⚠':'';
        foreach($ctx->crud as $tbl=>$f){
            $sh->fromArray([$ctx->path,$tbl,$f->c?'○':'',$f->r?'○':'',$f->u?'○':'',$f->d?'○':'',$unc],null,"A{$row}");
            $row++;
        }
        $row++; // 空行
    }
    (new Xlsx($s))->save($file); echo "✔ Excel: {$file}\n";
}
function exportLog(Project $p,string $file):void{
    if($p->log===[]) return; file_put_contents($file,implode("\n",$p->log)); echo "✔ Log:   {$file}\n";
}

/*────────────────────────── Main ─────────────────────────*/
$target=$argv[1]??''; if($target===''||!is_dir($target)){
    fwrite(STDERR,"usage: ./crud-analyzer.php <directory>\n"); exit(1);
}

/* initial scan */
$proj=new Project();
foreach(scan(realpath($target)) as $f) $proj->files[$f]=new FileContext($f);

/* collect function defs */
collectFunctions($proj);

/* optional view / proc lists */
$views=file_exists('view_list.txt')      ? file('view_list.txt',FILE_IGNORE_NEW_LINES)      : [];
$procs=file_exists('procedure_list.txt') ? file('procedure_list.txt',FILE_IGNORE_NEW_LINES) : [];

/* full analysis */
foreach(array_keys($proj->files) as $f) analyzeFile($f,$proj,$views,$procs);

/* output */
exportExcel($proj,__DIR__.'/File-CRUD.xlsx');
exportLog($proj,__DIR__.'/Log.txt');
echo "完了: files=".count($proj->files)."  funcs=".count($proj->funcDefs)."\n";