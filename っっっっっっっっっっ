/**
 * PHPコードの静的解析ツール
 * 
 * このツールは以下の機能を提供します：
 * - PHPファイルの静的解析
 * - SQLクエリの抽出とCRUD操作の分析
 * - 関数ブロックの解析
 * - 変数の追跡
 * - 分岐処理の解析
 */

<?php
require_once __DIR__ . '/vendor/autoload.php';

use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;
use PhpParser\NodeTraverser;
use PhpParser\PrettyPrinter\Standard;

/**
 * コメントを除去するビジター
 */
class CommentRemover extends NodeVisitorAbstract
{
    public function leaveNode(Node $node)
    {
        if ($node instanceof \PhpParser\Comment) {
            return NodeTraverser::REMOVE_NODE;
        }
        return null;
    }
}

/**
 * 文字列連結（.=）を正規化するビジター
 */
class StringConcatNormalizer extends NodeVisitorAbstract
{
    public function leaveNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Expr\AssignOp\Concat) {
            // .= を = と . に分解
            return new \PhpParser\Node\Expr\Assign(
                $node->var,
                new \PhpParser\Node\Expr\BinaryOp\Concat(
                    $node->var,
                    $node->expr
                )
            );
        }
        return null;
    }
}

/**
 * 文字列連結をまとめるビジター
 */
class StringConcatMerger extends NodeVisitorAbstract
{
    private $concatChains = [];
    private $currentVarName;
    private $constants = [];
    private $undefinedVars = [];
    /** @var array<string,bool> $definedVars */
    private $definedVars = [];

    /** 変数が未定義だった場合に代用するプレースホルダの前後テキスト */
    private string $undefPrefix = '{{';
    private string $undefSuffix = '}}';

    public function enterNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Stmt\Const_) {
            foreach ($node->consts as $const) {
                $this->constants[$const->name->name] = $this->getConstantValue($const->value);
            }
        } else if ($node instanceof \PhpParser\Node\Expr\FuncCall &&
                   $node->name instanceof \PhpParser\Node\Name &&
                   $node->name->toString() === 'define') {
            if (isset($node->args[0]) && isset($node->args[1])) {
                $name = $this->getConstantName($node->args[0]->value);
                if ($name !== null) {
                    $this->constants[$name] = $this->getConstantValue($node->args[1]->value);
                }
            }
        } else if ($node instanceof \PhpParser\Node\Expr\Variable) {
            // 変数の使用を記録
            if (!isset($this->undefinedVars[$node->name])) {
                $this->undefinedVars[$node->name] = true;
            }
        } else if ($node instanceof \PhpParser\Node\Expr\Assign) {
            $this->processAssignment($node);
        }
        return null;
    }

    private function getConstantName(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Scalar\String_) {
            return $node->value;
        } else if ($node instanceof \PhpParser\Node\Expr\ConstFetch) {
            return $node->name->toString();
        }
        return null;
    }

    private function getConstantValue(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Scalar\String_) {
            return $node->value;
        } else if ($node instanceof \PhpParser\Node\Scalar\LNumber) {
            return (string)$node->value;
        } else if ($node instanceof \PhpParser\Node\Scalar\DNumber) {
            return (string)$node->value;
        } else if ($node instanceof \PhpParser\Node\Expr\ConstFetch) {
            $name = $node->name->toString();
            if (isset($this->constants[$name])) {
                return $this->constants[$name];
            } else if (defined($name)) {
                return $this->convertConstantValue(constant($name));
            }
            // 未定義の定数は文字列として扱う
            return $name;
        } else if ($node instanceof \PhpParser\Node\Expr\BinaryOp\BooleanOr ||
                   $node instanceof \PhpParser\Node\Expr\BinaryOp\BooleanAnd) {
            return $this->evaluateBooleanExpression($node) ? 'true' : 'false';
        } else if ($node instanceof \PhpParser\Node\Expr\Variable) {
            // 未定義の変数は変数名を文字列として扱う
            return '$' . $node->name;
        }
        return null;
    }

    private function convertConstantValue($value)
    {
        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        } else if (is_numeric($value)) {
            return (string)$value;
        } else if (is_string($value)) {
            return $value;
        } else if (is_null($value)) {
            return 'null';
        }
        return null;
    }

    private function evaluateBooleanExpression(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Expr\BinaryOp\BooleanOr) {
            return $this->evaluateBooleanExpression($node->left) ||
                   $this->evaluateBooleanExpression($node->right);
        } else if ($node instanceof \PhpParser\Node\Expr\BinaryOp\BooleanAnd) {
            return $this->evaluateBooleanExpression($node->left) &&
                   $this->evaluateBooleanExpression($node->right);
        } else if ($node instanceof \PhpParser\Node\Expr\ConstFetch) {
            $name = $node->name->toString();
            if (isset($this->constants[$name])) {
                return $this->constants[$name] === 'true';
            } else if (defined($name)) {
                return (bool)constant($name);
            }
        }
        return false;
    }

    private function processAssignment(Node $node)
    {
        if (!$node instanceof \PhpParser\Node\Expr\Assign ||
            !$node->var instanceof \PhpParser\Node\Expr\Variable) {
            return;
        }

        $varName = $node->var->name;
        $this->currentVarName = $varName;
        // この変数はここで値が代入されたので「定義済み」とみなす
        $this->definedVars[$varName] = true;

        if (!isset($this->concatChains[$varName])) {
            $this->concatChains[$varName] = [];
        }

        if ($node->expr instanceof \PhpParser\Node\Expr\BinaryOp\Concat) {
            $this->collectConcatParts($node->expr, $this->concatChains[$varName]);
        } else {
            $this->concatChains[$varName] = [$node->expr];
        }
    }

    private function collectConcatParts(Node $node, array &$parts)
    {
        if ($node instanceof \PhpParser\Node\Expr\BinaryOp\Concat) {
            if ($node->left instanceof \PhpParser\Node\Expr\Variable && 
                $node->left->name === $this->currentVarName) {
                $this->collectConcatParts($node->right, $parts);
            } else {
                $this->collectConcatParts($node->left, $parts);
                $this->collectConcatParts($node->right, $parts);
            }
        } else if ($node instanceof \PhpParser\Node\Expr\ConstFetch) {
            $name = $node->name->toString();
            if (isset($this->constants[$name])) {
                $parts[] = new \PhpParser\Node\Scalar\String_($this->constants[$name]);
            } else if (defined($name)) {
                $value = $this->convertConstantValue(constant($name));
                if ($value !== null) {
                    $parts[] = new \PhpParser\Node\Scalar\String_($value);
                } else {
                    $parts[] = new \PhpParser\Node\Scalar\String_($name);
                }
            } else {
                $parts[] = new \PhpParser\Node\Scalar\String_($name);
            }
        } else if ($node instanceof \PhpParser\Node\Expr\Variable) {
            // 変数が未定義なら文字列リテラル「$変数名」をプレースホルダで囲って扱う
            $varName = is_string($node->name) ? $node->name : 'UNKNOWN';
            if (!isset($this->definedVars[$varName])) {
                $parts[] = new \PhpParser\Node\Scalar\String_($this->undefPrefix . '$' . $varName . $this->undefSuffix);
            } else {
                // 定義済みの変数はそのまま保持
                $parts[] = $node;
            }
        } else {
            $parts[] = $node;
        }
    }

    private function optimizeStringParts(array $parts): array
    {
        $optimizedParts = [];
        $stringGroups = [];
        $currentString = '';

        // 文字列リテラルをグループ化して最適化
        foreach ($parts as $part) {
            $part = $this->handleEmptyString($part);
            
            if ($part instanceof \PhpParser\Node\Scalar\String_) {
                $value = $part->value;
                // 空文字列はスキップ
                if ($value === '') {
                    continue;
                }
                // タイムスタンプパターンの検出と最適化
                if (preg_match('/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/', $value)) {
                    if (!isset($stringGroups['timestamp'])) {
                        $stringGroups['timestamp'] = ['value' => $value, 'count' => 0];
                    }
                    $stringGroups['timestamp']['count']++;
                    continue;
                }
                // 通常の文字列の最適化
                if (!isset($stringGroups[$value])) {
                    $stringGroups[$value] = ['value' => $value, 'count' => 0];
                }
                $stringGroups[$value]['count']++;
            } else {
                // 文字列グループを処理
                if (!empty($stringGroups)) {
                    foreach ($stringGroups as $group) {
                        if ($group['count'] > 1) {
                            $optimizedParts[] = new \PhpParser\Node\Scalar\String_($group['value']);
                        } else {
                            $optimizedParts[] = new \PhpParser\Node\Scalar\String_($group['value']);
                        }
                    }
                    $stringGroups = [];
                }
                $optimizedParts[] = $part;
            }
        }

        // 残りの文字列グループを処理
        if (!empty($stringGroups)) {
            foreach ($stringGroups as $group) {
                if ($group['count'] > 1) {
                    $optimizedParts[] = new \PhpParser\Node\Scalar\String_($group['value']);
                } else {
                    $optimizedParts[] = new \PhpParser\Node\Scalar\String_($group['value']);
                }
            }
        }

        return $this->mergeConsecutiveStrings($optimizedParts);
    }

    private function mergeConsecutiveStrings(array $parts): array
    {
        $result = [];
        $currentString = '';
        $prevLiteral = null;

        foreach ($parts as $part) {
            if ($part instanceof \PhpParser\Node\Scalar\String_) {
                $literal = $part->value;
                // 空文字列はスキップ
                if ($literal === '') {
                    continue;
                }

                // 連続する重複リテラルをスキップ
                if ($prevLiteral !== null && $prevLiteral === $literal) {
                    continue;
                }

                $currentString .= $literal;
                $prevLiteral = $literal;
            } else {
                if ($currentString !== '') {
                    $result[] = new \PhpParser\Node\Scalar\String_($currentString);
                    $currentString = '';
                    $prevLiteral = null;
                }
                $result[] = $part;
            }
        }

        // 残りの文字列を処理
        if ($currentString !== '') {
            $result[] = new \PhpParser\Node\Scalar\String_($currentString);
        }

        return $result;
    }

    private function handleEmptyString(Node $node): Node
    {
        if ($node instanceof \PhpParser\Node\Expr\Variable) {
            $varName = is_string($node->name) ? $node->name : 'UNKNOWN';
            if (!isset($this->definedVars[$varName])) {
                // SQLクエリやHTMLの属性値として使用される未定義変数の場合
                if ($this->isInSqlContext() || $this->isInHtmlContext()) {
                    return new \PhpParser\Node\Scalar\String_("''");
                }
                // 通常の未定義変数
                return new \PhpParser\Node\Scalar\String_($this->undefPrefix . '$' . $varName . $this->undefSuffix);
            }
        } else if ($node instanceof \PhpParser\Node\Scalar\String_) {
            if ($node->value === '') {
                // 空文字列の場合は空文字列を返す
                return new \PhpParser\Node\Scalar\String_('');
            }
        } else if ($node instanceof \PhpParser\Node\Expr\ConstFetch) {
            $name = $node->name->toString();
            if (!isset($this->constants[$name]) && !defined($name)) {
                // 未定義の定数は文字列として扱う
                return new \PhpParser\Node\Scalar\String_($name);
            }
        }
        return $node;
    }

    private function isInSqlContext(): bool
    {
        // SQLコンテキストの検出ロジック
        $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 5);
        foreach ($backtrace as $trace) {
            if (isset($trace['function']) && strpos($trace['function'], 'sql') !== false) {
                return true;
            }
        }
        return false;
    }

    private function isInHtmlContext(): bool
    {
        // HTMLコンテキストの検出ロジック
        $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 5);
        foreach ($backtrace as $trace) {
            if (isset($trace['function']) && strpos($trace['function'], 'html') !== false) {
                return true;
            }
        }
        return false;
    }

    public function leaveNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Expr\Assign &&
            $node->var instanceof \PhpParser\Node\Expr\Variable) {
            $varName = $node->var->name;
            
            if (isset($this->concatChains[$varName]) && 
                count($this->concatChains[$varName]) > 1) {
                $parts = $this->concatChains[$varName];
                
                // 文字列リテラルの最適化
                $optimizedParts = $this->optimizeStringParts($parts);

                // 未定義変数の処理を改善
                foreach ($optimizedParts as &$part) {
                    if ($part instanceof \PhpParser\Node\Expr\Variable) {
                        $varName = is_string($part->name) ? $part->name : 'UNKNOWN';
                        if (!isset($this->definedVars[$varName])) {
                            $part = new \PhpParser\Node\Scalar\String_($this->undefPrefix . '$' . $varName . $this->undefSuffix);
                        }
                    }
                }

                if (count($optimizedParts) === 1) {
                    return new \PhpParser\Node\Expr\Assign($node->var, $optimizedParts[0]);
                } else if (count($optimizedParts) > 1) {
                    $result = $optimizedParts[0];
                    for ($i = 1; $i < count($optimizedParts); $i++) {
                        $result = new \PhpParser\Node\Expr\BinaryOp\Concat($result, $optimizedParts[$i]);
                    }
                    return new \PhpParser\Node\Expr\Assign($node->var, $result);
                }
            }
        }
        return null;
    }

    /**
     * Returns a list of variables that were encountered but never defined.
     *
     * @return string[]
     */
    public function getUndefinedVariables(): array
    {
        return array_keys(array_diff_key($this->undefinedVars, $this->definedVars));
    }
}

/**
 * 連続した代入をまとめるビジター
 */
class ConsecutiveAssignmentMerger extends NodeVisitorAbstract
{
    /** @var \PhpParser\Node\Stmt\Expression|null */
    private $lastAssignStmt = null;

    public function enterNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Stmt\Expression &&
            $node->expr instanceof \PhpParser\Node\Expr\Assign &&
            $node->expr->var instanceof \PhpParser\Node\Expr\Variable
        ) {
            /** @var \PhpParser\Node\Expr\Assign $currentAssign */
            $currentAssign = $node->expr;
            /** @var \PhpParser\Node\Expr\Variable $var */
            $var = $currentAssign->var;
            $varName = $var->name;

            if ($this->lastAssignStmt &&
                $this->lastAssignStmt->expr instanceof \PhpParser\Node\Expr\Assign &&
                $this->lastAssignStmt->expr->var instanceof \PhpParser\Node\Expr\Variable &&
                $this->lastAssignStmt->expr->var->name === $varName
            ) {
                /** @var \PhpParser\Node\Expr\Assign $lastAssign */
                $lastAssign = $this->lastAssignStmt->expr;
                $exprToAppend = $currentAssign->expr;

                if ($exprToAppend instanceof \PhpParser\Node\Expr\BinaryOp\Concat &&
                    $exprToAppend->left instanceof \PhpParser\Node\Expr\Variable &&
                    $exprToAppend->left->name === $varName
                ) {
                    $exprToAppend = $exprToAppend->right;
                }

                $lastAssign->expr = new \PhpParser\Node\Expr\BinaryOp\Concat(
                    $lastAssign->expr,
                    $exprToAppend
                );

                return \PhpParser\NodeTraverser::REMOVE_NODE;
            }

            $this->lastAssignStmt = $node;
        } else {
            $this->lastAssignStmt = null;
        }

        return null;
    }
}

/**
 * 関数ブロックを解析するビジター
 */
class FunctionBlockAnalyzer extends NodeVisitorAbstract
{
    // 関数ブロックの情報を保持する配列
    private $functionBlocks = [];
    // メインコードの情報を保持する配列
    private $mainCode = [];
    // 現在処理中のブロック情報
    private $currentBlock = null;
    // クラス内の処理中かどうかのフラグ
    private $inClass = false;
    // 現在処理中のクラス名
    private $currentClass = null;
    // コード整形用のPrettyPrinter
    private $prettyPrinter;
    // SQLクエリの情報を保持する配列
    private $sqlQueries = [];
    // ビューの情報を保持する配列
    private $views = [];
    // 変数への代入情報を保持する配列
    private $varAssignments = [];
    // 分岐情報を保持するスタック
    private $branchStack = [];

    /**
     * コンストラクタ
     * PrettyPrinterの初期化とビュー情報の読み込みを行う
     */
    public function __construct()
    {
        $this->prettyPrinter = new Standard();
        $this->loadViews();
    }

    /**
     * ビュー情報を読み込む
     */
    private function loadViews()
    {
        $viewsFile = 'input/views.txt';
        if (file_exists($viewsFile)) {
            $content = file_get_contents($viewsFile);
            $this->views = array_map('trim', array_filter(explode("\n", $content)));
        }
    }

    /**
     * テーブル名を正規化する
     * 
     * @param string $tableName テーブル名
     * @return string 正規化されたテーブル名
     */
    private function normalizeTableName(string $tableName): string
    {
        // テーブル名を小文字に統一
        $tableName = strtolower($tableName);
        
        // ビューの検出
        if (in_array($tableName, $this->views)) {
            return $tableName . '@view';
        }
        
        // 一時テーブルの検出
        if (strpos($tableName, 'temp_') === 0) {
            return $tableName . '@temp';
        }
        
        return $tableName;
    }

    /**
     * SQLクエリからCRUD操作を解析する
     * 
     * @param string $sql SQLクエリ
     * @return array CRUD操作の配列
     */
    private function analyzeCrud(string $sql): array
    {
        $sql = strtoupper(trim($sql));
        $crud = [];
        
        // WITH句の処理
        if (preg_match_all('/WITH\s+([^\s(]+)\s+AS\s*\(([^)]+)\)/i', $sql, $matches, PREG_SET_ORDER)) {
            foreach ($matches as $match) {
                $cteName = $this->normalizeTableName($match[1]);
                $cteQuery = $match[2];
                $crud[] = ['table' => $cteName, 'operation' => 'C'];
                
                // WITH句内のクエリも解析
                $cteCrud = $this->analyzeCrud($cteQuery);
                $crud = array_merge($crud, $cteCrud);
            }
        }
        
        // SELECT
        if (preg_match('/SELECT.*FROM\s+([^\s,]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'R'];
        }
        
        // INSERT
        if (preg_match('/INSERT\s+INTO\s+([^\s(]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'C'];
            
            // INSERT ... SELECT の処理
            if (preg_match('/SELECT.*FROM\s+([^\s,]+)/i', $sql, $selectMatches)) {
                $selectTable = $this->normalizeTableName($selectMatches[1]);
                $crud[] = ['table' => $selectTable, 'operation' => 'R'];
            }
        }
        
        // UPDATE
        if (preg_match('/UPDATE\s+([^\s,]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'U'];
            
            // UPDATE ... FROM の処理
            if (preg_match('/FROM\s+([^\s,]+)/i', $sql, $fromMatches)) {
                $fromTable = $this->normalizeTableName($fromMatches[1]);
                $crud[] = ['table' => $fromTable, 'operation' => 'R'];
            }
        }
        
        // DELETE
        if (preg_match('/DELETE\s+FROM\s+([^\s,]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'D'];
        }
        
        // CREATE TEMP TABLE
        if (preg_match('/CREATE\s+TEMP\s+TABLE\s+([^\s(]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'C'];
            
            // AS SELECT の処理
            if (preg_match('/SELECT.*FROM\s+([^\s,]+)/i', $sql, $selectMatches)) {
                $selectTable = $this->normalizeTableName($selectMatches[1]);
                $crud[] = ['table' => $selectTable, 'operation' => 'R'];
            }
        }
        
        // JOINの処理
        if (preg_match_all('/JOIN\s+([^\s,]+)/i', $sql, $matches)) {
            foreach ($matches[1] as $tableName) {
                $tableName = $this->normalizeTableName($tableName);
                $crud[] = ['table' => $tableName, 'operation' => 'R'];
            }
        }
        
        // サブクエリの処理
        if (preg_match_all('/\(SELECT.*FROM\s+([^\s,]+)/i', $sql, $matches)) {
            foreach ($matches[1] as $tableName) {
                $tableName = $this->normalizeTableName($tableName);
                $crud[] = ['table' => $tableName, 'operation' => 'R'];
            }
        }

        // get_valueの第二引数のR判定
        if (preg_match('/get_value\s*\(\s*[^,]+,\s*([^,)]+)/i', $sql, $matches)) {
            $tableName = $this->normalizeTableName($matches[1]);
            $crud[] = ['table' => $tableName, 'operation' => 'R'];
        }
        
        // 重複を除去
        $uniqueCrud = [];
        foreach ($crud as $item) {
            $key = $item['table'] . ':' . $item['operation'];
            if (!isset($uniqueCrud[$key])) {
                $uniqueCrud[$key] = $item;
            }
        }
        
        return array_values($uniqueCrud);
    }

    public function enterNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Stmt\Class_) {
            $this->inClass = true;
            $this->currentClass = $node->name->name;
            $this->currentBlock = [
                'type' => 'class',
                'name' => $this->currentClass,
                'methods' => []
            ];
        } else if ($node instanceof \PhpParser\Node\Stmt\ClassMethod) {
            if ($this->inClass) {
                $this->currentBlock['methods'][] = [
                    'name' => $node->name->name,
                    'visibility' => $node->isPublic() ? 'public' : ($node->isProtected() ? 'protected' : 'private'),
                    'isStatic' => $node->isStatic()
                ];
            }
        } else if ($node instanceof \PhpParser\Node\Stmt\Function_) {
            $this->currentBlock = [
                'type' => 'function',
                'name' => $node->name->name
            ];
        } else if ($node instanceof \PhpParser\Node\Expr\Assign &&
                   $node->expr instanceof \PhpParser\Node\Scalar\String_) {
            // SQLクエリの検出
            $sql = $node->expr->value;
            if ($this->isSqlQuery($sql)) {
                $blockName = $this->getCurrentBlockName();
                $this->sqlQueries[] = [
                    'block' => $blockName,
                    'query' => $sql,
                    'crud' => $this->analyzeCrud($sql)
                ];
            }
        }

        // 分岐の検出
        if ($node instanceof \PhpParser\Node\Stmt\If_ || $node instanceof \PhpParser\Node\Stmt\ElseIf_ || $node instanceof \PhpParser\Node\Stmt\Else_) {
            array_push($this->branchStack, []);
        }

        // 変数への代入を記録
        if ($node instanceof \PhpParser\Node\Expr\Assign &&
            $node->var instanceof \PhpParser\Node\Expr\Variable &&
            $node->expr instanceof \PhpParser\Node\Scalar\String_) {
            $varName = $node->var instanceof \PhpParser\Node\Expr\Variable ? $node->var->name : 'unknown';
            $value = $node->expr instanceof \PhpParser\Node\Scalar\String_ ? $node->expr->value : '';
            if (!empty($this->branchStack)) {
                $branchIdx = count($this->branchStack) - 1;
                $this->branchStack[$branchIdx][$varName][] = $value;
            } else {
                $this->varAssignments[$varName][] = $value;
            }
        }

        return null;
    }

    private function isSqlQuery(string $sql): bool
    {
        $sql = strtoupper(trim($sql));
        $keywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'TRUNCATE', 'WITH'];
        foreach ($keywords as $keyword) {
            if (strpos($sql, $keyword) === 0) {
                return true;
            }
        }
        return false;
    }

    private function getCurrentBlockName(): string
    {
        if ($this->inClass && $this->currentBlock) {
            return $this->currentClass . '::' . end($this->currentBlock['methods'])['name'];
        } else if ($this->currentBlock) {
            return $this->currentBlock['name'];
        }
        return 'main';
    }

    public function leaveNode(Node $node)
    {
        if ($node instanceof \PhpParser\Node\Stmt\Class_) {
            $this->functionBlocks[] = $this->currentBlock;
            $this->inClass = false;
            $this->currentClass = null;
            $this->currentBlock = null;
        } else if ($node instanceof \PhpParser\Node\Stmt\Function_) {
            $this->functionBlocks[] = $this->currentBlock;
            $this->currentBlock = null;
        } else if (!$this->inClass && !$this->currentBlock) {
            // メイン処理のコードを収集
            $this->mainCode[] = $node;
        }

        // 分岐終了時に代入値を統合
        if ($node instanceof \PhpParser\Node\Stmt\If_ || $node instanceof \PhpParser\Node\Stmt\ElseIf_ || $node instanceof \PhpParser\Node\Stmt\Else_) {
            $branchVars = array_pop($this->branchStack);
            foreach ($branchVars as $varName => $values) {
                foreach ($values as $v) {
                    $this->varAssignments[$varName][] = $v;
                }
            }
        }

        return null;
    }

    public function getFunctionBlocks(): array
    {
        return $this->functionBlocks;
    }

    public function getMainCode(): string
    {
        if (empty($this->mainCode)) {
            return "メインコードはありません。\n";
        }

        $code = "=== メインコード ===\n\n";
        $currentComment = '';

        foreach ($this->mainCode as $node) {
            try {
                // コメントノードの処理
                if ($node instanceof \PhpParser\Node\Stmt\Expression &&
                    $node->expr instanceof \PhpParser\Node\Scalar\String_ &&
                    strpos($node->expr->value, '//') === 0) {
                    $currentComment = $node->expr instanceof \PhpParser\Node\Scalar\String_ ? $node->expr->value : '';
                    continue;
                }

                // 式の出力
                $nodeCode = $this->prettyPrinter->prettyPrint([$node]);
                
                // コメントがある場合は先に出力
                if ($currentComment !== '') {
                    $code .= $currentComment . "\n";
                    $currentComment = '';
                }

                // 式を出力（中間式を除外）
                if (!($node instanceof \PhpParser\Node\Expr\ArrayItem) &&
                    !($node instanceof \PhpParser\Node\Expr\ArrayDimFetch) &&
                    !($node instanceof \PhpParser\Node\Expr\PropertyFetch) &&
                    !($node instanceof \PhpParser\Node\Expr\StaticPropertyFetch) &&
                    !($node instanceof \PhpParser\Node\Expr\ClassConstFetch) &&
                    !($node instanceof \PhpParser\Node\Expr\ConstFetch) &&
                    !($node instanceof \PhpParser\Node\Scalar\String_) &&
                    !($node instanceof \PhpParser\Node\Scalar\LNumber) &&
                    !($node instanceof \PhpParser\Node\Scalar\DNumber) &&
                    !($node instanceof \PhpParser\Node\Expr\BinaryOp\Concat)) {
                    $code .= $nodeCode . "\n";
                }
            } catch (\Exception $e) {
                $code .= "// コードの復元中にエラーが発生しました: " . $e->getMessage() . "\n";
            }
        }

        return $code;
    }

    public function getSqlQueries(): array
    {
        return $this->sqlQueries;
    }

    // SQL抽出時に全パターンを出力
    public function getAllSqlCandidates(): array
    {
        $sqls = [];
        foreach ($this->varAssignments as $varName => $values) {
            foreach ($values as $v) {
                if ($this->isSqlQuery($v)) {
                    $sqls[] = [
                        'var' => $varName,
                        'query' => $v,
                        'crud' => $this->analyzeCrud($v)
                    ];
                }
            }
        }
        return $sqls;
    }
}

/**
 * ファイル解析クラス
 */
class FileAnalyzer
{
    // 解析対象ディレクトリ
    private $directory;
    // ビューの情報を保持する配列
    private $views = [];
    // PHPパーサー
    private $parser;
    // 警告を抑制するかどうかのフラグ
    private $suppressWarnings = false;
    // 関数ブロック解析器
    private $functionBlockAnalyzer;
    // 大きなファイルを処理する際のチャンクサイズ
    private $chunkSize = 1024 * 1024; // 1MB

    public function __construct($directory = null, $suppressWarnings = false)
    {
        $this->directory = $directory;
        $this->suppressWarnings = $suppressWarnings;
        $this->loadViews();
        $this->parser = (new ParserFactory)->createForNewestSupportedVersion();
        $this->functionBlockAnalyzer = new FunctionBlockAnalyzer();
        
        if ($this->suppressWarnings) {
            error_reporting(E_ALL & ~E_WARNING);
        }
    }

    private function loadViews()
    {
        $viewsFile = 'input/views.txt';
        if (file_exists($viewsFile)) {
            $content = file_get_contents($viewsFile);
            $this->views = array_filter(explode("\n", $content));
        }
    }

    /**
     * @return array<string>
     */
    public function getViews()
    {
        return $this->views;
    }

    public function scanDirectory()
    {
        $files = [];
        $this->recursiveScan($this->directory, $files);
        return $files;
    }

    private function recursiveScan($dir, &$files)
    {
        $items = scandir($dir);
        foreach ($items as $item) {
            if ($item === '.' || $item === '..') {
                continue;
            }
            $path = $dir . DIRECTORY_SEPARATOR . $item;
            if (is_dir($path)) {
                $this->recursiveScan($path, $files);
            } else {
                // 相対パスを取得
                $relativePath = str_replace($this->directory . DIRECTORY_SEPARATOR, '', $path);
                $files[] = [
                    'path' => $relativePath,
                    'function_name' => '',
                    'table_name' => '',
                    'create' => '',
                    'read' => '',
                    'update' => '',
                    'delete' => '',
                    'note' => ''
                ];

                // PHPファイルまたはincファイルの場合、開始タグを正規化し、コメントを除去
                $extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
                if ($extension === 'php' || $extension === 'inc') {
                    $this->normalizePhpStartTag($path);
                    $this->removeComments($path);
                    $this->normalizeStringConcat($path);
                    $this->mergeStringConcat($path);
                    $this->analyzeFunctionBlocks($path);
                }
            }
        }
    }

    /**
     * PHPファイルの開始タグを<?phpに正規化する
     * 
     * @param string $filePath 対象ファイルのパス
     */
    private function normalizePhpStartTag($filePath)
    {
        $content = file_get_contents($filePath);
        if ($content === false) {
            return;
        }

        // 短縮形の開始タグを<?phpに置換（<?=は除外）
        $normalized = preg_replace('/^<\?(?!php|=)/m', '<?php', $content);
        
        // 変更があった場合のみファイルを書き込み
        if ($normalized !== $content) {
            file_put_contents($filePath, $normalized);
        }
    }

    private function removeComments($filePath)
    {
        $code = file_get_contents($filePath);
        if ($code === false) {
            return;
        }

        try {
            $statements = $this->parser->parse($code);
            if ($statements === null) {
                return;
            }

            $traverser = new NodeTraverser();
            $traverser->addVisitor(new CommentRemover());
            $newStatements = $traverser->traverse($statements);

            $prettyPrinter = new Standard();
            $newCode = $prettyPrinter->prettyPrintFile($newStatements);

            file_put_contents($filePath, $newCode);
        } catch (\PhpParser\Error $e) {
            echo "ファイル {$filePath} の解析中にエラーが発生しました: " . $e->getMessage() . "\n";
            // 失敗したファイルパスをテキストに保存
            file_put_contents('failed_files.txt', $filePath . "\n", FILE_APPEND);
        }
    }

    /**
     * 文字列連結（.=）を正規化する
     * 
     * @param string $filePath 対象ファイルのパス
     */
    private function normalizeStringConcat($filePath)
    {
        $code = file_get_contents($filePath);
        if ($code === false) {
            return;
        }

        try {
            $statements = $this->parser->parse($code);
            if ($statements === null) {
                return;
            }

            $traverser = new NodeTraverser();
            $traverser->addVisitor(new StringConcatNormalizer());
            $newStatements = $traverser->traverse($statements);

            $prettyPrinter = new Standard();
            $newCode = $prettyPrinter->prettyPrintFile($newStatements);

            file_put_contents($filePath, $newCode);
        } catch (\PhpParser\Error $e) {
            echo "ファイル {$filePath} の文字列連結正規化中にエラーが発生しました: " . $e->getMessage() . "\n";
        }
    }

    /**
     * 文字列連結をまとめる
     * 
     * @param string $filePath 対象ファイルのパス
     */
    private function mergeStringConcat($filePath)
    {
        $code = file_get_contents($filePath);
        if ($code === false) {
            return;
        }

        try {
            $statements = $this->parser->parse($code);
            if ($statements === null) {
                return;
            }

            $traverser = new NodeTraverser();
            $stringConcatMerger = new StringConcatMerger();
            $traverser->addVisitor($stringConcatMerger);
            $traverser->addVisitor(new ConsecutiveAssignmentMerger());
            $newStatements = $traverser->traverse($statements);

            // 未定義変数のログ出力
            $undefined = $stringConcatMerger->getUndefinedVariables();
            if ($undefined) {
                file_put_contents('undefined_vars.log',
                    $filePath . ":\n  " . implode(", ", $undefined) . "\n",
                    FILE_APPEND);
            }

            $prettyPrinter = new Standard();
            $newCode = $prettyPrinter->prettyPrintFile($newStatements);

            file_put_contents($filePath, $newCode);
        } catch (\PhpParser\Error $e) {
            if (!$this->suppressWarnings) {
                echo "ファイル {$filePath} の文字列連結まとめ中にエラーが発生しました: " . $e->getMessage() . "\n";
            }
        }
    }

    private function processLargeFile($filePath)
    {
        $handle = fopen($filePath, 'r');
        if ($handle === false) {
            throw new \RuntimeException("ファイルを開けませんでした: $filePath");
        }

        $content = '';
        while (!feof($handle)) {
            $chunk = fread($handle, $this->chunkSize);
            if ($chunk === false) {
                break;
            }
            $content .= $chunk;
            
            // メモリ使用量が閾値を超えた場合、GCを実行
            if (memory_get_usage() > 100 * 1024 * 1024) { // 100MB
                gc_collect_cycles();
            }
        }
        fclose($handle);

        return $content;
    }

    public function analyzeFunctionBlocks(string $filePath)
    {
        if (!file_exists($filePath)) {
            throw new \RuntimeException("指定されたファイルが見つかりません: $filePath");
        }

        try {
            // 大きなファイルの場合は分割して処理
            $content = $this->processLargeFile($filePath);
            $parser = (new ParserFactory)->createForNewestSupportedVersion();
            $ast = $parser->parse($content);

            $analyzer = new FunctionBlockAnalyzer();
            $traverser = new NodeTraverser();
            $traverser->addVisitor($analyzer);
            $traverser->traverse($ast);

            // 解析結果をログに出力
            $this->logAnalysisResults($analyzer, $filePath);

        } catch (\PhpParser\Error $e) {
            // 静的解析に失敗した場合、正規表現ベースのフォールバック処理を実行
            $this->fallbackAnalysis($filePath);
        }
    }

    private function fallbackAnalysis($filePath)
    {
        $content = file_get_contents($filePath);
        if ($content === false) {
            return;
        }

        // 正規表現ベースのSQL抽出
        $sqlPatterns = [
            '/SELECT.*?FROM\s+([^\s,;]+)/i',
            '/INSERT\s+INTO\s+([^\s(;]+)/i',
            '/UPDATE\s+([^\s,;]+)/i',
            '/DELETE\s+FROM\s+([^\s,;]+)/i',
            '/CREATE\s+TEMP\s+TABLE\s+([^\s(;]+)/i'
        ];

        $log = "=== フォールバック解析結果 ===\n\n";
        $log .= "ファイル: " . $filePath . "\n\n";

        foreach ($sqlPatterns as $pattern) {
            if (preg_match_all($pattern, $content, $matches)) {
                foreach ($matches[1] as $tableName) {
                    $tableName = strtolower(trim($tableName));
                    $operation = $this->determineOperation($pattern);
                    $log .= "テーブル: $tableName (操作: $operation)\n";
                }
            }
        }

        file_put_contents('fallback_analysis.log', $log, FILE_APPEND);
    }

    private function determineOperation($pattern): string
    {
        if (strpos($pattern, 'SELECT') !== false) return 'R';
        if (strpos($pattern, 'INSERT') !== false) return 'C';
        if (strpos($pattern, 'UPDATE') !== false) return 'U';
        if (strpos($pattern, 'DELETE') !== false) return 'D';
        if (strpos($pattern, 'CREATE') !== false) return 'C';
        return '?';
    }

    private function logAnalysisResults($analyzer, $filePath)
    {
        $log = "=== 関数ブロック解析結果 ===\n\n";
        $log .= "ファイル: " . $filePath . "\n\n";
        
        // 関数ブロックの情報
        $log .= "関数ブロック:\n";
        foreach ($analyzer->getFunctionBlocks() as $block) {
            $log .= "- タイプ: " . $block['type'] . "\n";
            $log .= "  名前: " . $block['name'] . "\n";
            if ($block['type'] === 'class') {
                $log .= "  メソッド:\n";
                foreach ($block['methods'] as $method) {
                    $log .= "    - " . $method['visibility'] . 
                           ($method['isStatic'] ? ' static' : '') . 
                           " " . $method['name'] . "\n";
                }
            }
            $log .= "\n";
        }

        // SQLクエリの解析結果
        $log .= "SQLクエリ:\n";
        foreach ($analyzer->getSqlQueries() as $query) {
            $log .= "- ブロック: " . $query['block'] . "\n";
            $log .= "  クエリ: " . $query['query'] . "\n";
            $log .= "  CRUD操作:\n";
            foreach ($query['crud'] as $crud) {
                $log .= "    - テーブル: " . $crud['table'] . 
                       " (操作: " . $crud['operation'] . ")\n";
            }
            $log .= "\n";
        }

        // 分岐SQL候補の出力
        $log .= "分岐SQL候補:\n";
        foreach ($analyzer->getAllSqlCandidates() as $sql) {
            $log .= "- 変数: " . $sql['var'] . "\n";
            $log .= "  クエリ: " . $sql['query'] . "\n";
            $log .= "  CRUD操作:\n";
            foreach ($sql['crud'] as $crud) {
                $log .= "    - テーブル: " . $crud['table'] . " (操作: " . $crud['operation'] . ")\n";
            }
            $log .= "\n";
        }

        // メインコード
        $log .= $analyzer->getMainCode();

        file_put_contents('function_blocks.log', $log);
    }

    public function exportToExcel($files)
    {
        $spreadsheet = new Spreadsheet();
        $sheet = $spreadsheet->getActiveSheet();
        $sheet->setTitle('CRUD分析結果');

        // ヘッダーを設定
        $headers = [
            'A1' => 'ファイル名',
            'B1' => '関数名',
            'C1' => 'テーブル名',
            'D1' => 'C',
            'E1' => 'R',
            'F1' => 'U',
            'G1' => 'D',
            'H1' => '注釈'
        ];

        foreach ($headers as $cell => $value) {
            $sheet->setCellValue($cell, $value);
            $sheet->getStyle($cell)->getFont()->setBold(true);
        }

        // ファイル情報をエクセルに書き込む
        $row = 2;
        foreach ($files as $file) {
            // 相対パスを取得
            $relativePath = $this->getRelativePath($file['path']);
            
            $sheet->setCellValue('A' . $row, $relativePath);
            $sheet->setCellValue('B' . $row, $file['function_name']);
            $sheet->setCellValue('C' . $row, $file['table_name']);
            $sheet->setCellValue('D' . $row, $file['create']);
            $sheet->setCellValue('E' . $row, $file['read']);
            $sheet->setCellValue('F' . $row, $file['update']);
            $sheet->setCellValue('G' . $row, $file['delete']);
            $sheet->setCellValue('H' . $row, $file['note']);
            
            // 注釈がある場合は背景色を設定
            if (!empty($file['note'])) {
                $sheet->getStyle('H' . $row)->getFill()
                    ->setFillType(\PhpOffice\PhpSpreadsheet\Style\Fill::FILL_SOLID)
                    ->getStartColor()->setRGB('FFFF00');
            }
            
            $row++;
        }

        // 列幅を自動調整
        foreach (range('A', 'H') as $col) {
            $sheet->getColumnDimension($col)->setAutoSize(true);
        }

        // フィルターを設定
        $sheet->setAutoFilter('A1:H' . ($row - 1));

        // エクセルファイルを保存
        $writer = new Xlsx($spreadsheet);
        $outputDir = 'output';
        if (!is_dir($outputDir)) {
            mkdir($outputDir, 0777, true);
        }
        $writer->save($outputDir . '/file_analysis.xlsx');
    }

    private function getRelativePath($path)
    {
        if (empty($this->directory)) {
            return $path;
        }

        // 絶対パスの場合
        if (strpos($path, '/') === 0) {
            return $path;
        }

        // 相対パスの場合
        return str_replace($this->directory . DIRECTORY_SEPARATOR, '', $path);
    }
}

// メイン処理（グローバルスコープ）
if (php_sapi_name() == "cli") {
    $directory = $argv[1] ?? null;
    if ($directory && is_dir($directory)) {
        $analyzer = new FileAnalyzer($directory);
        $files = $analyzer->scanDirectory();
        $analyzer->exportToExcel($files);
        echo "ファイル分析結果をエクセルに出力しました: file_analysis.xlsx\n";
        
        // views.txtの内容を表示
        $views = $analyzer->getViews();
        if (!empty($views)) {
            echo "\n検出されたビュー:\n";
            foreach ($views as $view) {
                echo "- " . trim($view) . "\n";
            }
        }
    } else {
        echo "有効なディレクトリを指定してください。\n";
        echo "使用方法: php analyzer.php <ディレクトリパス>\n";
    }
}


