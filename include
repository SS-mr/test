#!/usr/bin/env php
<?php
declare(strict_types=1);

require __DIR__ . '/vendor/autoload.php';

use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpOffice\PhpSpreadsheet\Settings;
use PhpOffice\PhpSpreadsheet\CachedObjectStorageFactory;

/*────────────────────────── メモリ節約設定 ──────────────────────────*/
$cacheMethod   = CachedObjectStorageFactory::cache_to_phpTemp;
$cacheSettings = ['memoryCacheSize' => '16MB'];
Settings::setCacheStorageMethod($cacheMethod, $cacheSettings);
Settings::setAutoSizeMethod(Settings::AUTOSIZE_METHOD_APPROX);

/*────────────────────────── 定数など ─────────────────────────────*/
const ALLOWED_EXT = ['php', 'inc'];

/*────────────────────────── AST Visitor for Assignments ──────────────────────────*/
class AssignVisitor extends NodeVisitorAbstract
{
    /** @var array<string,string> 変数名→文字列リテラル */
    public array $vars = [];

    public function enterNode(Node $node)
    {
        // simple: $foo = 'bar'; 
        if ($node instanceof Node\Expr\Assign
            && $node->var instanceof Node\Expr\Variable
            && is_string($node->var->name)) {
            $value = $this->resolveValue($node->expr);
            if ($value !== null) {
                $this->vars[$node->var->name] = $value;
            }
        }
    }

    /** 再帰的に文字列 or concat を評価 */
    private function resolveValue(Node $expr): ?string
    {
        if ($expr instanceof Node\Scalar\String_) {
            return $expr->value;
        }
        if ($expr instanceof Node\Expr\Variable
            && is_string($expr->name)
            && isset($this->vars[$expr->name])) {
            return $this->vars[$expr->name];
        }
        if ($expr instanceof Node\Expr\BinaryOp\Concat) {
            $l = $this->resolveValue($expr->left);
            $r = $this->resolveValue($expr->right);
            if ($l !== null && $r !== null) {
                return $l . $r;
            }
        }
        return null;
    }
}

/*────────────────────────── ヘルパ関数群 ──────────────────────────*/
/** ディレクトリをジェネレータで再帰走査 */
function iterateSourceFiles(string $dir): Generator
{
    $it = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS)
    );
    foreach ($it as $f) {
        if ($f->isFile()
            && in_array(strtolower($f->getExtension()), ALLOWED_EXT, true)) {
            yield $f->getPathname();
        }
    }
}

/** フォールバック: 文字列リテラルの include/require 抽出 */
function fallbackIncludes(string $code, string $baseDir): array
{
    preg_match_all(
        '#\b(include|include_once|require|require_once)\s*(?:\(\s*)?[\'"]([^\'"]+)[\'"]#i',
        $code,
        $m
    );
    $paths = [];
    foreach ($m[2] ?? [] as $raw) {
        $paths[] = resolvePath($raw, $baseDir, null);
    }
    return array_unique($paths);
}

/**
 * 生文字列 or 結合結果を受け取り、
 *   - 絶対パスで指定されていればそのまま realpath  or raw
 *   - 相対パスなら baseDir 経由で realpath → projectRoot からの相対パス
 *   - projectRoot 外はその実パス(絶対)を返す
 */
function resolvePath(string $raw, string $baseDir, ?string $projectRoot): string
{
    $isAbsolute = (bool)preg_match('#^([A-Za-z]:[\\/]|/)#', $raw);
    $joined     = $isAbsolute ? $raw : $baseDir . DIRECTORY_SEPARATOR . $raw;
    $real       = realpath($joined) ?: $joined;

    if (!$isAbsolute && $projectRoot !== null && str_starts_with($real, $projectRoot)) {
        // projectRoot 以下なら相対化
        $rel = substr($real, strlen($projectRoot));
        return ltrim(str_replace('\\', '/', $rel), '/');
    }
    return $real;
}

/** 1 ファイルの include を AST + フォールバック で抽出 */
function extractIncludes(
    string $file,
    \PhpParser\Parser $parser,
    string $projectRoot
): array {
    $code    = file_get_contents($file);
    if ($code === false) return [];

    $baseDir = dirname($file);
    $vars    = new AssignVisitor();
    $trav1   = new NodeTraverser();
    $trav1->addVisitor($vars);

    // ASTパース & 変数割当だけ1回
    try {
        $ast = $parser->parse($code);
        $trav1->traverse($ast);
    } catch (\Throwable) {
        // ignore
    }

    $includes = [];
    // 次に include ノードだけ別訪問
    foreach ($ast ?? [] as $node) {
        if ($node instanceof Node\Expr\Include_) {
            $val = null;
            // 文字列リテラル
            if ($node->expr instanceof Node\Scalar\String_) {
                $val = $node->expr->value;
            }
            // 変数
            elseif ($node->expr instanceof Node\Expr\Variable
                && is_string($node->expr->name)
                && isset($vars->vars[$node->expr->name])) {
                $val = $vars->vars[$node->expr->name];
            }
            // concat
            elseif ($node->expr instanceof Node\Expr\BinaryOp\Concat) {
                $val = $vars->resolveValue($node->expr);
            }
            if ($val !== null) {
                $includes[] = resolvePath($val, $baseDir, $projectRoot);
            }
        }
    }

    // ASTで何も拾えなければフォールバック
    if (empty($includes)) {
        $includes = fallbackIncludes($code, $baseDir);
    }

    // 重複除去
    return array_values(array_unique($includes));
}

/** transitive include を逐次的に列挙 */
function walkTransitive(
    string $root,
    callable $directFetcher,
    callable $onEdge
): void {
    $queue   = new SplQueue();
    $visited = [];
    foreach ($directFetcher($root) as $inc) {
        $queue->enqueue([$inc, 1]);
    }
    while (!$queue->isEmpty()) {
        [$cur, $depth] = $queue->dequeue();
        if (isset($visited[$cur])) continue;
        $visited[$cur] = true;
        $onEdge($depth, $cur);
        foreach ($directFetcher($cur) as $child) {
            $queue->enqueue([$child, $depth + 1]);
        }
    }
}

/*────────────────────────── Main Entry ───────────────────────────*/
if ($argc < 2) {
    fwrite(STDERR, "Usage: php include_analyzer.php <project_root> [output.xlsx]\n");
    exit(1);
}
$projectRoot = realpath($argv[1]);
if (!$projectRoot || !is_dir($projectRoot)) {
    fwrite(STDERR, "Invalid directory: {$argv[1]}\n");
    exit(1);
}
$outFile = $argv[2] ?? 'include_analysis.xlsx';

$parser = (new ParserFactory())->createForNewestSupportedVersion();

/* Excel 初期化 */
$book        = new Spreadsheet();
$directSheet = $book->getActiveSheet()
    ->setTitle('Include-Direct')
    ->fromArray(['File', 'Included (direct)'], null, 'A1');
$allSheet = $book->createSheet()
    ->setTitle('Include-All')
    ->fromArray(['Root File', 'Depth', 'Included (transitive)'], null, 'A1');
$directRow = $allRow = 2;

$includeCache = [];
$fetchDirect  = function(string $f) use (&$includeCache) {
    return $includeCache[$f] ?? [];
};

/* 再帰走査 & 逐次書き込み */
foreach (iterateSourceFiles($projectRoot) as $absFile) {
    // 相対パス化
    $file = str_starts_with($absFile, $projectRoot)
        ? ltrim(substr($absFile, strlen($projectRoot)), DIRECTORY_SEPARATOR)
        : $absFile;

    // direct
    $incs = extractIncludes(
        $absFile, $parser, $projectRoot
    );
    $includeCache[$file] = $incs;

    if (empty($incs)) {
        $directSheet->setCellValue("A{$directRow}", $file);
        $directRow++;
    } else {
        foreach ($incs as $i => $inc) {
            $directSheet->fromArray([
                $i === 0 ? $file : '',
                $inc
            ], null, "A{$directRow}");
            $directRow++;
        }
    }

    // transitive
    walkTransitive(
        $file,
        fn($f) => $includeCache[$f] ?? [],
        function($depth, $path) use (&$allSheet, &$allRow, $file) {
            $allSheet->fromArray([$file, $depth, $path], null, "A{$allRow}");
            $allRow++;
        }
    );

    // メモリ解放
    unset($includeCache[$file]);
    gc_collect_cycles();
}

/* 列幅自動調整 */
foreach ([$directSheet, $allSheet] as $sh) {
    foreach (['A','B','C'] as $col) {
        $sh->getColumnDimension($col)->setAutoSize(true);
    }
}

/* 保存 */
(new Xlsx($book))->save($outFile);
echo "✓ Include analysis written → {$outFile}\n";