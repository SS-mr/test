#!/usr/bin/env php
<?php
declare(strict_types=1);

require __DIR__ . '/vendor/autoload.php';

use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpOffice\PhpSpreadsheet\Settings;
use PhpOffice\PhpSpreadsheet\CachedObjectStorageFactory;

/*────────────────────────── メモリ節約設定 ──────────────────────────*/
Settings::setCacheStorageMethod(
    CachedObjectStorageFactory::cache_to_phpTemp,
    ['memoryCacheSize' => '16MB']
);
Settings::setAutoSizeMethod(Settings::AUTOSIZE_METHOD_APPROX);

/*────────────────────────── 定数 ─────────────────────────────*/
const ALLOWED_EXT = ['php', 'inc'];

/*────────────────────────── AST Visitor for $var = ... ──────────────────────────*/
class AssignVisitor extends NodeVisitorAbstract
{
    public array $vars = []; // ['path'=>'../foo.php', ...]

    public function enterNode(Node $node)
    {
        // $var = 'literal'; / $var = $otherVar; / $var = $a . 'b';
        if (
            $node instanceof Node\Expr\Assign
            && $node->var instanceof Node\Expr\Variable
            && is_string($node->var->name)
        ) {
            $val = $this->resolveValue($node->expr);
            if ($val !== null) {
                $this->vars[$node->var->name] = $val;
            }
        }
    }

    // AST外からも呼べるよう public に
    public function resolveValue(Node $expr): ?string
    {
        if ($expr instanceof Node\Scalar\String_) {
            return $expr->value;
        }
        if (
            $expr instanceof Node\Expr\Variable
            && is_string($expr->name)
            && isset($this->vars[$expr->name])
        ) {
            return $this->vars[$expr->name];
        }
        if ($expr instanceof Node\Expr\BinaryOp\Concat) {
            $l = $this->resolveValue($expr->left);
            $r = $this->resolveValue($expr->right);
            if ($l !== null && $r !== null) {
                return $l . $r;
            }
        }
        return null;
    }
}

/*────────────────────────── ヘルパ関数群 ──────────────────────────*/
// 再帰ファイル走査（Generator）
function iterateSourceFiles(string $dir): Generator
{
    $it = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS)
    );
    foreach ($it as $f) {
        if (
            $f->isFile()
            && in_array(strtolower($f->getExtension()), ALLOWED_EXT, true)
        ) {
            yield $f->getPathname();
        }
    }
}

// 正規表現フォールバックで「生文字列リテラル」だけ捕捉
function fallbackIncludes(string $code): array
{
    preg_match_all(
        '#\b(include|include_once|require|require_once)\s*(?:\(\s*)?[\'"]([^\'"]+)[\'"]#i',
        $code,
        $m
    );
    return array_unique($m[2] ?? []);
}

// 絶対/相対の raw 値を決め打ちしつつ、「解析用ID (fileId)」を返す
function makeFileId(string $absPath, string $projectRoot): string
{
    $norm = str_replace('\\','/',$absPath);
    if (str_starts_with($norm, $projectRoot.'/')) {
        return ltrim(substr($norm, strlen($projectRoot)), '/');
    }
    return $norm;
}

// raw の文字列を filesystem 上のパスに解決
function resolvePath(string $raw, string $baseDir): string
{
    // 絶対リテラルならそのまま realpath → raw も unchanged
    if (preg_match('#^([A-Za-z]:[\\/]|/)#', $raw)) {
        return realpath($raw) ?: $raw;
    }
    // 相対は baseDir 経由
    $joined = $baseDir . DIRECTORY_SEPARATOR . $raw;
    return realpath($joined) ?: $joined;
}

/**
 * AST＋フォールバックで「raw文字列」と「解析用 fileId」を返す
 * [
 *   ['raw'=>'../inc/util.php','id'=>'inc/util.php'],
 *   ['raw'=>'/etc/config.php','id'=>'/etc/config.php'],
 *   ...
 * ]
 */
function extractIncludes(
    string $absFile,
    \PhpParser\Parser $parser,
    string $projectRoot
): array {
    $code    = file_get_contents($absFile) ?: '';
    $baseDir = dirname($absFile);

    // 1) 変数割当収集
    $assignVis = new AssignVisitor();
    try {
        $ast = $parser->parse($code);
        (new NodeTraverser())->addVisitor($assignVis)->traverse($ast);
    } catch (\Throwable) {
        $ast = [];
    }

    $entries = [];
    // 2) Include_ ノードごとに raw を取得
    foreach ($ast as $node) {
        if (! $node instanceof Node\Expr\Include_) {
            continue;
        }
        $raw = null;
        // 文字列リテラル
        if ($node->expr instanceof Node\Scalar\String_) {
            $raw = $node->expr->value;
        }
        // 変数展開
        elseif (
            $node->expr instanceof Node\Expr\Variable
            && isset($assignVis->vars[$node->expr->name])
        ) {
            $raw = $assignVis->vars[$node->expr->name];
        }
        // 文字列連結
        elseif ($node->expr instanceof Node\Expr\BinaryOp\Concat) {
            $raw = $assignVis->resolveValue($node->expr);
        }

        if ($raw !== null) {
            $abs = resolvePath($raw, $baseDir);
            $id  = makeFileId($abs, $projectRoot);
            $entries[$id] = ['raw' => $raw, 'id' => $id];
        }
    }

    // 3) ASTで何も取れなければフォールバック
    if (empty($entries)) {
        foreach (fallbackIncludes($code) as $raw) {
            $abs = resolvePath($raw, $baseDir);
            $id  = makeFileId($abs, $projectRoot);
            $entries[$id] = ['raw'=>$raw,'id'=>$id];
        }
    }

    // ensure numeric index
    return array_values($entries);
}

// 深さ付き再帰走査：raw付き
function walkTransitive(
    string $rootId,
    callable $getEntries,
    callable $onEdge
): void {
    $queue   = new SplQueue();
    $visited = [];

    foreach ($getEntries($rootId) as $e) {
        $queue->enqueue([$e['id'], 1, $e['raw']]);
    }

    while (!$queue->isEmpty()) {
        [$cur, $depth, $raw] = $queue->dequeue();
        if (isset($visited[$cur])) continue;
        $visited[$cur] = true;
        $onEdge($depth, $raw);

        foreach ($getEntries($cur) as $e) {
            $queue->enqueue([$e['id'], $depth+1, $e['raw']]);
        }
    }
}

/*────────────────────────── Main ───────────────────────────*/
if ($argc < 2) {
    fwrite(STDERR, "Usage: php include_analyzer.php <project_root> [output.xlsx]\n");
    exit(1);
}
$projectRoot = str_replace('\\','/', realpath($argv[1]) ?: '');
if (!$projectRoot || !is_dir($projectRoot)) {
    fwrite(STDERR, "Invalid directory: {$argv[1]}\n");
    exit(1);
}
$outFile = $argv[2] ?? 'include_analysis.xlsx';

$parser = (new ParserFactory())->createForNewestSupportedVersion();

// Excel 準備
$book        = new Spreadsheet();
$directSheet = $book->getActiveSheet()
    ->setTitle('Include-Direct')
    ->fromArray(['File','Included (direct)'],null,'A1');
$allSheet    = $book->createSheet()
    ->setTitle('Include-All')
    ->fromArray(['Root File','Depth','Included (transitive)'],null,'A1');
$directRow = $allRow = 2;

// ファイル→インクルード情報キャッシュ
$includeCache = [];

// 再帰走査 & 逐次書込
foreach (iterateSourceFiles($projectRoot) as $absFile) {
    // ファイルID = projectRoot下は相対パス, それ以外は絶対パス
    $fileId = makeFileId($absFile, $projectRoot);

    // 直接解析
    $entries = extractIncludes($absFile, $parser, $projectRoot);
    $includeCache[$fileId] = $entries;

    // Include-Direct シート
    if (empty($entries)) {
        $directSheet->fromArray([$fileId,''], null, "A{$directRow}");
        $directRow++;
    } else {
        foreach ($entries as $i => $e) {
            $directSheet->fromArray([
                $i===0 ? $fileId : '',
                $e['raw']
            ], null, "A{$directRow}");
            $directRow++;
        }
    }

    // Include-All シート
    walkTransitive(
        $fileId,
        fn($id) => $includeCache[$id] ?? [],
        function(int $depth, string $raw) use(&$allSheet,&$allRow,$fileId) {
            $allSheet->fromArray([$fileId,$depth,$raw], null, "A{$allRow}");
            $allRow++;
        }
    );

    // メモリ解放
    unset($includeCache[$fileId]);
    gc_collect_cycles();
}

// 列幅調整
foreach ([$directSheet,$allSheet] as $sh) {
    foreach (['A','B','C'] as $col) {
        $sh->getColumnDimension($col)->setAutoSize(true);
    }
}

// 保存
(new Xlsx($book))->save($outFile);
echo "✓ Include analysis written → {$outFile}\n";