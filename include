#!/usr/bin/env php
<?php
declare(strict_types=1);

require __DIR__ . '/vendor/autoload.php';

use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpOffice\PhpSpreadsheet\Settings;
use PhpOffice\PhpSpreadsheet\CachedObjectStorageFactory;

/*────────────────────────── メモリ節約設定（未実装環境はスキップ） ──────────────────────────*/
if (
    class_exists(Settings::class)
    && method_exists(Settings::class, 'setCacheStorageMethod')
    && method_exists(CachedObjectStorageFactory::class, 'cache_to_phpTemp')
) {
    Settings::setCacheStorageMethod(
        CachedObjectStorageFactory::cache_to_phpTemp,
        ['memoryCacheSize' => '16MB']
    );
}
if (
    class_exists(Settings::class)
    && method_exists(Settings::class, 'setAutoSizeMethod')
) {
    Settings::setAutoSizeMethod(Settings::AUTOSIZE_METHOD_APPROX);
}

/*────────────────────────── 定数 ─────────────────────────────*/
const ALLOWED_EXT = ['php', 'inc'];

/*────────────────────────── AST Visitor for $var assignments ──────────────────────────*/
class AssignVisitor extends NodeVisitorAbstract
{
    /** @var array<string,string> 変数名→文字列リテラル */
    public array $vars = [];

    public function enterNode(Node $node)
    {
        if (
            $node instanceof Node\Expr\Assign
            && $node->var instanceof Node\Expr\Variable
            && is_string($node->var->name)
        ) {
            $val = $this->resolveValue($node->expr);
            if ($val !== null) {
                $this->vars[$node->var->name] = $val;
            }
        }
    }

    /** AST外からも呼べるよう public に変更 */
    public function resolveValue(Node $expr): ?string
    {
        if ($expr instanceof Node\Scalar\String_) {
            return $expr->value;
        }
        if (
            $expr instanceof Node\Expr\Variable
            && is_string($expr->name)
            && isset($this->vars[$expr->name])
        ) {
            return $this->vars[$expr->name];
        }
        if ($expr instanceof Node\Expr\BinaryOp\Concat) {
            $l = $this->resolveValue($expr->left);
            $r = $this->resolveValue($expr->right);
            if ($l !== null && $r !== null) {
                return $l . $r;
            }
        }
        return null;
    }
}

/*────────────────────────── ヘルパ関数群 ──────────────────────────*/
/**
 * 再帰ディレクトリ走査ジェネレータ
 * @return Generator<string>
 */
function iterateSourceFiles(string $dir): Generator
{
    $it = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS)
    );
    foreach ($it as $f) {
        if ($f->isFile()
            && in_array(strtolower($f->getExtension()), ALLOWED_EXT, true)
        ) {
            yield $f->getPathname();
        }
    }
}

/**
 * フォールバック正規表現で生文字列リテラルだけ抽出
 * @return string[]
 */
function fallbackIncludes(string $code): array
{
    preg_match_all(
        '#\b(include|include_once|require|require_once)\s*(?:\(\s*)?[\'"]([^\'"]+)[\'"]#i',
        $code,
        $m
    );
    return array_unique($m[2] ?? []);
}

/**
 * 生文字列 raw を filesystem パスに解決
 */
function resolvePath(string $raw, string $baseDir): string
{
    if (preg_match('#^([A-Za-z]:[\\/]|/)#', $raw)) {
        return realpath($raw) ?: $raw;
    }
    $joined = $baseDir . DIRECTORY_SEPARATOR . $raw;
    return realpath($joined) ?: $joined;
}

/**
 * projectRoot 以下なら相対パス、それ以外は絶対パスを返す
 */
function makeFileId(string $absPath, string $projectRoot): string
{
    $norm = str_replace('\\','/',$absPath);
    if (str_starts_with($norm, $projectRoot . '/')) {
        return ltrim(substr($norm, strlen($projectRoot)), '/');
    }
    return $norm;
}

/**
 * 1 ファイルの include を AST + フォールバック で抽出
 * @return array<int,array{raw:string,id:string}>
 */
function extractIncludes(
    string $absFile,
    \PhpParser\Parser $parser,
    string $projectRoot
): array {
    $code    = file_get_contents($absFile) ?: '';
    $baseDir = dirname($absFile);

    // 1) 変数割当収集
    $assignVis = new AssignVisitor();
    try {
        $ast = $parser->parse($code) ?? [];
    } catch (\Throwable) {
        $ast = [];
    }
    $trav = new NodeTraverser();
    $trav->addVisitor($assignVis);
    $trav->traverse($ast);

    $entries = [];
    // 2) Include_ ノードから raw を取得
    foreach ($ast as $node) {
        if (! $node instanceof Node\Expr\Include_) continue;
        $raw = null;
        if ($node->expr instanceof Node\Scalar\String_) {
            $raw = $node->expr->value;
        } elseif (
            $node->expr instanceof Node\Expr\Variable
            && isset($assignVis->vars[$node->expr->name])
        ) {
            $raw = $assignVis->vars[$node->expr->name];
        } elseif ($node->expr instanceof Node\Expr\BinaryOp\Concat) {
            $raw = $assignVis->resolveValue($node->expr);
        }
        if ($raw !== null) {
            $abs = resolvePath($raw, $baseDir);
            $id  = makeFileId($abs, $projectRoot);
            $entries[$id] = ['raw'=>$raw,'id'=>$id];
        }
    }

    // 3) ASTで何も取れなければフォールバック
    if (empty($entries)) {
        foreach (fallbackIncludes($code) as $raw) {
            $abs = resolvePath($raw, $baseDir);
            $id  = makeFileId($abs, $projectRoot);
            $entries[$id] = ['raw'=>$raw,'id'=>$id];
        }
    }

    return array_values($entries);
}

/**
 * 深さ付き再帰走査：raw を保持してコールバック
 * @param callable(string):array<int,array{raw:string,id:string}> $getEntries
 * @param callable(int,string):void $onEdge
 */
function walkTransitive(
    string $rootId,
    callable $getEntries,
    callable $onEdge
): void {
    $queue   = new SplQueue();
    $visited = [];

    foreach ($getEntries($rootId) as $e) {
        $queue->enqueue([$e['id'], 1, $e['raw']]);
    }
    while (!$queue->isEmpty()) {
        [$cur, $depth, $raw] = $queue->dequeue();
        if (isset($visited[$cur])) continue;
        $visited[$cur] = true;
        $onEdge($depth, $raw);
        foreach ($getEntries($cur) as $e) {
            $queue->enqueue([$e['id'], $depth+1, $e['raw']]);
        }
    }
}

/*────────────────────────── Main Entry ───────────────────────────*/
if ($argc < 2) {
    fwrite(STDERR, "Usage: php include_analyzer.php <project_root> [output.xlsx]\n");
    exit(1);
}
$projectRoot = str_replace('\\','/', realpath($argv[1]) ?: '');
if (!$projectRoot || !is_dir($projectRoot)) {
    fwrite(STDERR, "Invalid directory: {$argv[1]}\n");
    exit(1);
}
$outFile = $argv[2] ?? 'include_analysis.xlsx';

// Parser を createForNewestSupportedVersion() でインスタンス化
$parser = (new ParserFactory())->createForNewestSupportedVersion();

// Excel 初期化
$book        = new Spreadsheet();
$directSheet = $book->getActiveSheet()
    ->setTitle('Include-Direct')
    ->fromArray(['File','Included (direct)'],null,'A1');
$allSheet    = $book->createSheet()
    ->setTitle('Include-All')
    ->fromArray(['Root File','Depth','Included (transitive)'],null,'A1');
$directRow = $allRow = 2;

// キャッシュ領域
$includeCache = [];

/* 再帰ファイル走査 & 逐次書き込み */
foreach (iterateSourceFiles($projectRoot) as $absFile) {
    $fileId = makeFileId($absFile, $projectRoot);

    // 直接解析
    $entries = extractIncludes($absFile, $parser, $projectRoot);
    $includeCache[$fileId] = $entries;

    // Include-Direct
    if (empty($entries)) {
        $directSheet->fromArray([$fileId, ''], null, "A{$directRow}");
        $directRow++;
    } else {
        foreach ($entries as $i => $e) {
            $directSheet->fromArray([
                $i===0 ? $fileId : '',
                $e['raw']
            ], null, "A{$directRow}");
            $directRow++;
        }
    }

    // Include-All
    walkTransitive(
        $fileId,
        fn($id) => $includeCache[$id] ?? [],
        function(int $depth, string $raw) use (&$allSheet, &$allRow, $fileId) {
            $allSheet->fromArray([$fileId, $depth, $raw], null, "A{$allRow}");
            $allRow++;
        }
    );

    // メモリ解放
    unset($includeCache[$fileId]);
    gc_collect_cycles();
}

// 列幅調整
foreach ([$directSheet, $allSheet] as $sh) {
    foreach (['A','B','C'] as $col) {
        $sh->getColumnDimension($col)->setAutoSize(true);
    }
}

// 保存
(new Xlsx($book))->save($outFile);
echo "✓ Include analysis written → {$outFile}\n";