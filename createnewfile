#!/usr/bin/env php
<?php
declare(strict_types=1);

$argv = $_SERVER['argv'];
array_shift($argv);

if (empty($argv) || in_array($argv[0], ['-h', '--help'], true)) {
    fwrite(STDERR, <<<HELP
    usage: php cleanup.php <file|directory>

      整形後のファイルはカレントディレクトリの edited/ 以下に出力されます。
      元ファイルは上書きしません。

    HELP);
    exit($argv ? 0 : 1);
}

$targetPath = realpath($argv[0]);
if ($targetPath === false) {
    fwrite(STDERR, "Error: path not found.\n");
    exit(1);
}

$files = collectPhpFiles($targetPath);
if (!$files) {
    fwrite(STDERR, "No PHP/INC files found.\n");
    exit(0);
}

$basePath   = is_file($targetPath) ? dirname($targetPath) : rtrim($targetPath, DIRECTORY_SEPARATOR);
$cwd        = getcwd();
$editedRoot = $cwd . DIRECTORY_SEPARATOR . 'edited';

if (!is_dir($editedRoot) && !mkdir($editedRoot, 0777, true) && !is_dir($editedRoot)) {
    fwrite(STDERR, "Error: cannot create 'edited' directory.\n");
    exit(1);
}

foreach ($files as $file) {
    $source = toUtf8(file_get_contents($file));
    $userConsts = collectUserDefinedConstants($source);
    $defined = array_merge(
        array_keys(get_defined_constants(true)['Core'] ?? get_defined_constants()),
        $userConsts
    );
    $clean = transformSource($source, $defined);

    $relative = ltrim(substr($file, strlen($basePath)), DIRECTORY_SEPARATOR);
    $destPath = $editedRoot . DIRECTORY_SEPARATOR . $relative;

    $dir = dirname($destPath);
    if (!is_dir($dir) && !mkdir($dir, 0777, true) && !is_dir($dir)) {
        fwrite(STDERR, "Error: mkdir failed: {$dir}\n");
        continue;
    }

    file_put_contents($destPath, $clean);
    echo "[OK]  {$destPath}\n";
}

/* === 以下は関数定義部 === */

function collectPhpFiles(string $path): array
{
    if (is_file($path)) {
        return preg_match('/\.(php|inc)$/i', $path) ? [$path] : [];
    }

    $iter = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator(
            $path,
            FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS
        )
    );

    $files = [];
    foreach ($iter as $info) {
        /** @var SplFileInfo $info */
        if ($info->isFile() && preg_match('/\.(php|inc)$/i', $info->getFilename())) {
            $files[] = $info->getRealPath();
        }
    }
    return $files;
}

function collectUserDefinedConstants(string $code): array
{
    if (preg_match_all(
        '/\bdefine\s*\(\s*[\'"]([A-Z_\x80-\xff][A-Z0-9_\x80-\xff]*)[\'"]\s*,/i',
        $code,
        $m
    )) {
        return $m[1];
    }
    return [];
}

function transformSource(string $code, array $definedConsts): string
{
    $tokens = token_get_all($code);
    $tokens = quoteArrayKeys($tokens, $definedConsts);
    return rebuildSource($tokens);
}

function quoteArrayKeys(array $tokens, array $definedConsts): array
{
    $n = count($tokens);

    for ($i = 0; $i < $n; $i++) {
        if ($tokens[$i] !== '[') {
            continue;
        }

        $j = $i + 1;
        while ($j < $n && is_array($tokens[$j]) && $tokens[$j][0] === T_WHITESPACE) {
            $j++;
        }
        if ($j >= $n || !is_array($tokens[$j]) || $tokens[$j][0] !== T_STRING) {
            continue;
        }

        $key = $tokens[$j][1];
        $k = $j + 1;
        while ($k < $n && is_array($tokens[$k]) && $tokens[$k][0] === T_WHITESPACE) {
            $k++;
        }
        if ($k >= $n || !in_array($tokens[$k], [']', '=>'], true)) {
            continue;
        }

        if (in_array(strtolower($key), ['true', 'false', 'null'], true)) {
            continue;
        }
        if (in_array($key, $definedConsts, true)) {
            continue;
        }

        $tokens[$j] = [T_CONSTANT_ENCAPSED_STRING, "'" . addcslashes($key, "'\\") . "'"];
    }
    return $tokens;
}

function rebuildSource(array $tokens): string
{
    $out = '';
    $prevNL = false;
    $needSpace = false;

    foreach ($tokens as $tok) {
        if (is_array($tok)) {
            [$id, $text] = $tok;

            switch ($id) {
                case T_COMMENT:
                case T_DOC_COMMENT:
                    continue 2;

                case T_WHITESPACE:
                    if (strpos($text, "\n") !== false) {
                        if (!$prevNL) {
                            $out .= "\n";
                            $prevNL = true;
                        }
                        $needSpace = false;
                    } else {
                        $needSpace = true;
                    }
                    continue 2;

                default:
                    if ($needSpace && (ctype_alnum($text[0]) || $text[0] === '_')) {
                        $out .= ' ';
                    }
                    $out .= $text;
                    $prevNL = false;
                    $needSpace = false;
            }
        } else {
            $out .= $tok;
            $prevNL = ($tok === "\n");
            $needSpace = false;
        }
    }
    return $out;
}

function toUtf8(string $str): string
{
    if (function_exists('mb_detect_encoding')) {
        $enc = mb_detect_encoding(
            $str,
            ['UTF-8', 'SJIS', 'EUC-JP', 'ISO-8859-1'],
            true
        ) ?: 'UTF-8';
        $str = mb_convert_encoding($str, 'UTF-8', $enc);
    }
    return ltrim($str, "\xEF\xBB\xBF");
}