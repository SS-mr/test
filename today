#!/usr/bin/env php
<?php
declare(strict_types=1);

require __DIR__ . '/vendor/autoload.php';

use PhpParser\ParserFactory;
use PhpParser\Error as PhpParserError;
use PhpParser\PrettyPrinter\Standard;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpParser\Node;
use PHPSQLParser\PHPSQLParser;
use PHPSQLParser\PHPSQLParserException;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;

//--------------------------------------------------
// Preprocessor: コメント／空白除去、定数・変数展開、文字列結合正規化
//--------------------------------------------------
class Preprocessor
{
    private $parser;
    private $printer;
    private $consts = [];
    private $vars   = [];

    public function __construct()
    {
        $factory = new ParserFactory();
        $this->parser  = $factory->createForNewestSupportedVersion();
        $this->printer = new Standard();
    }

    /**
     * @throws PhpParserError
     */
    public function process(string $code): string
    {
        // AST 解析（構文エラーは上位でキャッチ）
        $ast   = $this->parser->parse($code);
        $clean = $this->printer->prettyPrintFile($ast);

        $this->collectDefinesAndVars($ast);
        $clean = $this->normalizeStrings($clean);
        $clean = $this->expandSymbols($clean);

        // 空白・改行正規化
        $clean = preg_replace('/[ \t]+/', ' ', $clean);
        $clean = preg_replace('/\r?\n\s*/', "\n", $clean);
        return trim($clean);
    }

    private function collectDefinesAndVars(array $ast): void
    {
        foreach ($ast as $node) {
            if ($node instanceof Node\Stmt\Const_) {
                foreach ($node->consts as $c) {
                    $v = $c->value;
                    if ($v instanceof Node\Scalar\String_ || $v instanceof Node\Scalar\LNumber || $v instanceof Node\Scalar\DNumber) {
                        $this->consts[$c->name->name] = $v->value;
                    }
                }
            }
            if ($node instanceof Node\Stmt\Expression
                && $node->expr instanceof Node\Expr\Assign
                && $node->expr->var instanceof Node\Expr\Variable
                && $node->expr->expr instanceof Node\Scalar\String_) {
                $this->vars[$node->expr->var->name] = $node->expr->expr->value;
            }
            if ($node instanceof Node\Stmt\Expression
                && $node->expr instanceof Node\Expr\FuncCall
                && $node->expr->name->toString() === 'define'
            ) {
                $args = $node->expr->args;
                if (isset($args[0], $args[1])
                    && $args[0]->value instanceof Node\Scalar\String_
                    && $args[1]->value instanceof Node\Scalar\String_) {
                    $this->consts[$args[0]->value->value] = $args[1]->value->value;
                }
            }
        }
    }

    private function normalizeStrings(string $code): string
    {
        return preg_replace_callback(
            '/"([^"]*)"(\s*\.\s*|\s*\.=\s*)"([^"]*)"/',
            fn($m) => '"' . $m[1] . $m[3] . '"',
            $code
        );
    }

    private function expandSymbols(string $code): string
    {
        foreach ($this->consts as $k => $v) {
            $code = str_replace($k, (string)$v, $code);
        }
        foreach ($this->vars as $k => $v) {
            $code = str_replace('$' . $k, (string)$v, $code);
        }
        return $code;
    }
}

//--------------------------------------------------
// FunctionAnalyzer: AST から関数定義と呼び出しのコールグラフを構築
//--------------------------------------------------
class FunctionAnalyzer
{
    private $functions = [];   // file => functionNames[]
    private $callGraph = [];   // file => [calleeFile=>true]
    private $parser;

    public function __construct()
    {
        $factory = new ParserFactory();
        $this->parser = $factory->createForNewestSupportedVersion();
    }

    public function analyzeAll(array $fileCodeMap, array &$syntaxErrors): void
    {
        foreach ($fileCodeMap as $file => $code) {
            try {
                $ast = $this->parser->parse($code);
            } catch (PhpParserError $e) {
                $syntaxErrors[] = ['file'=>$file, 'error'=>$e->getMessage()];
                continue;
            }
            $this->functions[$file] = $this->collectFunctions($ast);
        }
        foreach ($fileCodeMap as $file => $code) {
            try {
                $ast = $this->parser->parse($code);
            } catch (PhpParserError $e) {
                continue;
            }
            $calls = $this->collectCalls($ast);
            foreach ($calls as $fn) {
                foreach ($this->functions as $defFile => $fns) {
                    if (in_array($fn, $fns, true)) {
                        $this->callGraph[$file][$defFile] = true;
                    }
                }
            }
        }
    }

    public function getCallGraph(): array
    {
        return $this->callGraph;
    }

    private function collectFunctions(array $ast): array
    {
        $list = [];
        $tr   = new NodeTraverser();
        $tr->addVisitor(new class($list) extends NodeVisitorAbstract {
            public $list;
            public function __construct(&$list) { $this->list = &$list; }
            public function enterNode(Node $node) {
                if ($node instanceof Node\Stmt\Function_) {
                    $this->list[] = $node->name->name;
                }
            }
        });
        $tr->traverse($ast);
        return $list;
    }

    private function collectCalls(array $ast): array
    {
        $calls = [];
        $tr    = new NodeTraverser();
        $tr->addVisitor(new class($calls) extends NodeVisitorAbstract {
            public $calls;
            public function __construct(&$calls) { $this->calls = &$calls; }
            public function enterNode(Node $node) {
                if ($node instanceof Node\Expr\FuncCall && $node->name instanceof Node\Name) {
                    $this->calls[] = $node->name->toString();
                }
            }
        });
        $tr->traverse($ast);
        return $calls;
    }
}

//--------------------------------------------------
// SQLExtractor: PHPSQLParser + .=複数行対応、例外吸収
//--------------------------------------------------
class SQLExtractor
{
    private $parser;
    private $views;
    private $procs;

    public function __construct()
    {
        $this->parser = new PHPSQLParser();
        $this->views  = file_exists('views_list.txt') ? array_map('trim', file('views_list.txt')) : [];
        $this->procs  = file_exists('procs_list.txt') ? array_map('trim', file('procs_list.txt')) : [];
    }

    public function extractFromCode(string $code): array
    {
        $results = [];
        $logs    = [];

        // 1) .= 連結収集
        $sqlVars = [];
        foreach (explode("\n", $code) as $line) {
            if (preg_match('/\$(\w+)\s*=\s*["\']([^"\']*)["\']/', $line, $m)) {
                $sqlVars[$m[1]] = $m[2];
            } elseif (preg_match('/\$(\w+)\s*\.=\s*["\']([^"\']*)["\']/', $line, $m)) {
                $sqlVars[$m[1]] = ($sqlVars[$m[1]] ?? '') . $m[2];
            }
        }
        foreach ($sqlVars as $sql) {
            try {
                $ast = $this->parser->parse($sql, true);
            } catch (\Exception $e) {
                continue;
            }
            foreach ($ast as $entry) {
                $this->analyzeEntry($entry, $results);
            }
        }

        // 2) インラインSQL
        foreach (preg_split('/;\s*/', $code) as $stmt) {
            $stmt = trim($stmt);
            if ($stmt === '') continue;
            try {
                $ast = $this->parser->parse($stmt, true);
            } catch (\Exception $e) {
                continue;
            }
            foreach ($ast as $entry) {
                $this->analyzeEntry($entry, $results);
            }
        }

        // 3) 条件分岐ログ
        if (preg_match_all('/\b(if|switch)\s*\((.*?)\)/i', $code, $m)) {
            foreach ($m[0] as $cond) {
                $logs[] = ['cond' => $cond];
            }
        }

        return [$results, $logs];
    }

    private function analyzeEntry(array $entry, array &$out): void
    {
        $type = strtoupper(
            $entry['INSERT']   ? 'INSERT' :
            ($entry['UPDATE'] ? 'UPDATE' :
            ($entry['DELETE'] ? 'DELETE' :
            ($entry['CREATE'] ? 'CREATE' : 'SELECT')))
        );

        if ($type === 'CREATE'
            && !empty($entry['CREATE']['temporary'])
            && stripos($entry['CREATE']['temporary'], 'TEMP') !== false
        ) {
            $tbl = $entry['CREATE']['table'];
            $out[] = ['table'=>$tbl,'C'=>false,'R'=>false,'U'=>false,'D'=>false,'TEMP'=>$tbl];
            return;
        }

        $tables = [];
        if (!empty($entry['FROM'])) {
            foreach ($entry['FROM'] as $f) {
                $tables[] = $f['table'] ?? null;
                $tables[] = $f['alias']['name'] ?? null;
            }
        }
        if (!empty($entry['JOIN'])) {
            foreach ($entry['JOIN'] as $j) {
                $tables[] = $j['table'];
            }
        }

        foreach (array_filter(array_unique($tables)) as $tbl) {
            $isView = in_array(strtolower($tbl), array_map('strtolower', $this->views), true);
            $out[] = [
                'table'=> $tbl . ($isView?'@view':''), 
                'C'=> in_array($type,['INSERT','CREATE'],true),
                'R'=> $type==='SELECT'||$type==='UPDATE'||$type==='DELETE'|| !empty($entry['JOIN'])||!empty($entry['WITH']),
                'U'=> $type==='UPDATE',
                'D'=> $type==='DELETE',
                'TEMP'=>''
            ];
        }
    }
}

//--------------------------------------------------
// CRUDAggregator: ファイルごと CRUD 集約 + 関数伝播、例外不要
//--------------------------------------------------
class CRUDAggregator
{
    private $callGraph;

    public function __construct(array $callGraph)
    {
        $this->callGraph = $callGraph;
    }

    public function aggregate(array $fileSqlMap): array
    {
        $crudMap = [];
        foreach ($fileSqlMap as $file => $entries) {
            foreach ($entries as $e) {
                $tbl = $e['table'];
                $this->initTable($crudMap[$file], $tbl);
                foreach (['C','R','U','D'] as $op) {
                    $crudMap[$file][$tbl][$op] = $crudMap[$file][$tbl][$op] || $e[$op];
                }
                if ($e['TEMP']) {
                    $crudMap[$file][$tbl]['TEMP'] = $e['TEMP'];
                }
            }
        }
        foreach (array_keys($crudMap) as $file) {
            $this->propagate($file, $crudMap, []);
        }
        return $crudMap;
    }

    private function propagate(string $file, array &$map, array $visited): void
    {
        if (isset($visited[$file])) return;
        $visited[$file] = true;
        foreach (($this->callGraph[$file] ?? []) as $callee => $_) {
            $this->propagate($callee, $map, $visited);
            foreach ($map[$callee] ?? [] as $tbl => $ops) {
                $this->initTable($map[$file], $tbl);
                foreach (['C','R','U','D'] as $op) {
                    $map[$file][$tbl][$op] = $map[$file][$tbl][$op] || $ops[$op];
                }
                if ($ops['TEMP']) {
                    $map[$file][$tbl]['TEMP'] = $ops['TEMP'];
                }
            }
        }
    }

    private function initTable(&$fileMap, string $tbl): void
    {
        if (!isset($fileMap[$tbl])) {
            $fileMap[$tbl] = ['C'=>false,'R'=>false,'U'=>false,'D'=>false,'TEMP'=>''];
        }
    }
}

//--------------------------------------------------
// ExcelExporter: PhpSpreadsheet で File-CRUD と LOGS を出力
//--------------------------------------------------
class ExcelExporter
{
    public function export(string $path, array $crudMap, array $logs, array $syntaxErrors): void
    {
        $wb = new Spreadsheet();
        $ws = $wb->getActiveSheet();
        $ws->setTitle('File-CRUD');

        $ws->fromArray(['Table Name','C','R','U','D','TEMP'], null, 'A1');
        $row = 2;
        foreach ($crudMap as $file => $tables) {
            $ws->setCellValue("A{$row}", "File: {$file}");
            $row++;
            foreach ($tables as $tbl => $ops) {
                $ws->setCellValue("A{$row}", $tbl);
                $ws->setCellValue("B{$row}", $ops['C'] ? '○' : '');
                $ws->setCellValue("C{$row}", $ops['R'] ? '○' : '');
                $ws->setCellValue("D{$row}", $ops['U'] ? '○' : '');
                $ws->setCellValue("E{$row}", $ops['D'] ? '○' : '');
                $ws->setCellValue("F{$row}", $ops['TEMP']);
                $row++;
            }
            $row++;
        }

        // LOGS
        $logSheet = $wb->createSheet();
        $logSheet->setTitle('LOGS');
        $logSheet->fromArray(['Type','Detail'], null, 'A1');
        $r = 2;
        foreach ($syntaxErrors as $err) {
            $logSheet->setCellValue("A{$r}", 'SYNTAX_ERROR');
            $logSheet->setCellValue("B{$r}", "{$err['file']}: {$err['error']}");
            $r++;
        }
        foreach ($logs as $l) {
            $logSheet->setCellValue("A{$r}", 'CONDITION');
            $logSheet->setCellValue("B{$r}", $l['cond']);
            $r++;
        }

        (new Xlsx($wb))->save($path);
    }
}

//--------------------------------------------------
// エントリポイント
//--------------------------------------------------
function main(array $argv): void
{
    $projectDir = $argv[1] ?? null;
    if (!$projectDir || !is_dir($projectDir)) {
        fwrite(STDERR, "Usage: php analyzer.php /path/to/project\n");
        exit(1);
    }

    $rii   = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($projectDir));
    $files = [];
    foreach ($rii as $file) {
        if ($file->isFile() && preg_match('/\.(php|inc|html|js)$/i', $file->getFilename())) {
            $files[] = $file->getPathname();
        }
    }

    $pre          = new Preprocessor();
    $cleaned      = [];
    $syntaxErrors = [];

    // 前処理
    foreach ($files as $path) {
        $code = @file_get_contents($path);
        if ($code === false) {
            $syntaxErrors[] = ['file'=>$path, 'error'=>'Cannot read file'];
            continue;
        }
        try {
            $cleaned[$path] = $pre->process($code);
        } catch (PhpParserError $e) {
            $syntaxErrors[] = ['file'=>$path, 'error'=>$e->getMessage()];
        }
    }

    // 関数解析
    $funcAnalyzer = new FunctionAnalyzer();
    $funcAnalyzer->analyzeAll($cleaned, $syntaxErrors);

    // SQL抽出
    $sqlExt     = new SQLExtractor();
    $fileSqlMap = [];
    $logs       = [];
    foreach ($cleaned as $path => $code) {
        try {
            [$entries, $conds] = $sqlExt->extractFromCode($code);
            $fileSqlMap[$path] = $entries;
            $logs = array_merge($logs, $conds);
        } catch (\Throwable $e) {
            $syntaxErrors[] = ['file'=>$path, 'error'=>'SQL parse error: '.$e->getMessage()];
        }
    }

    // CRUD集約・伝播
    $aggregator = new CRUDAggregator($funcAnalyzer->getCallGraph());
    $crudMap    = $aggregator->aggregate($fileSqlMap);

    // Excel出力
    $exporter = new ExcelExporter();
    $exporter->export('analysis_result.xlsx', $crudMap, $logs, $syntaxErrors);

    echo "解析完了: analysis_result.xlsx を出力しました\n";
}

main($argv);