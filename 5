#!/usr/bin/env php
<?php
/**
 * analyzer.php — 完全対応 PHPソースコード解析ツール
 *
 * 仕様に基づきフォルダ内のPHP/HTML/JSファイルを解析し、
 * CRUD操作の抽出、SQL結合処理、プロシージャ・ビュー・一時テーブル検出を行い、
 * Excelファイルに出力します。
 */

require 'vendor/autoload.php';

use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PHPSQLParser\PHPSQLParser;
use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;

date_default_timezone_set('Asia/Tokyo');
error_reporting(E_ALL);

// === グローバル変数 ===
$crud_data = [];   // CRUD情報の蓄積
$log_data  = [];   // ログ情報の蓄積
$defines   = [];   // 定数定義
$views     = file_exists("view_list.txt") ? file("view_list.txt", FILE_IGNORE_NEW_LINES) : [];
$procs     = file_exists("procedure_list.txt") ? file("procedure_list.txt", FILE_IGNORE_NEW_LINES) : [];

// === 対象ディレクトリ取得 ===
$target_dir = $argv[1] ?? '.';
if (!is_dir($target_dir)) {
    fwrite(STDERR, "ディレクトリが無効です: $target_dir\n");
    exit(1);
}

// === 対象ファイルの一覧を取得（再帰的に探索）===
$rii = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($target_dir));
$files = [];
foreach ($rii as $file) {
    if ($file->isDir()) continue;
    $ext = strtolower($file->getExtension());
    if (in_array($ext, ['php', 'inc', 'html', 'js'])) {
        $files[] = $file->getPathname();
    }
}

// === 各ファイルごとに処理 ===
foreach ($files as $file_path) {
    $rel_path = substr($file_path, strlen(realpath($target_dir)) + 1);
    $code = file_get_contents($file_path);
    $clean_code = removeComments($code, $file_path);
    try {
        analyzePhpCode($clean_code, $rel_path);
    } catch (Throwable $e) {
        logMessage("AST解析失敗: $rel_path → fallback実行");
        fallbackParse($clean_code, $rel_path);
    }
}
// コメント除去関数（PHP/HTML/JS対応）
function removeComments($code, $file_path) {
    $ext = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
    switch ($ext) {
        case 'php':
        case 'inc':
            $code = preg_replace('/\/\/.*$/m', '', $code);           // 単一行コメント（//）
            $code = preg_replace('/#.*$/m', '', $code);              // 単一行コメント（#）
            $code = preg_replace('/\/\*[\s\S]*?\*\//', '', $code);   // 複数行コメント（/* */）
            break;
        case 'js':
            $code = preg_replace('/\/\/.*$/m', '', $code);
            $code = preg_replace('/\/\*[\s\S]*?\*\//', '', $code);
            break;
        case 'html':
            $code = preg_replace('/<!--[\s\S]*?-->/', '', $code);
            break;
    }
    return $code;
}

// ログ追加関数
function logMessage($message) {
    global $log_data;
    $log_data[] = [date('Y-m-d H:i:s'), $message];
}
// ASTベースのPHPコード解析
function analyzePhpCode($code, $rel_path) {
    global $crud_data, $defines;

    $parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);
    $ast = $parser->parse($code);
    if (!$ast) return;

    $traverser = new NodeTraverser();
    $traverser->addVisitor(new class($rel_path) extends NodeVisitorAbstract {
        private $file;
        public function __construct($file) { $this->file = $file; }

        public function enterNode(Node $node) {
            // define('TABLE_NAME', 'users') のような定数定義
            if ($node instanceof Node\Expr\FuncCall && $node->name instanceof Node\Name && strtolower($node->name->toString()) === 'define') {
                if (isset($node->args[0], $node->args[1])) {
                    $key = trim($node->args[0]->value);
                    $val = trim($node->args[1]->value);
                    if ($key && $val) $GLOBALS['defines'][$key] = $val;
                }
            }
            // 文字列結合されたSQLの解決などは fallback に一任（処理不可箇所多いため）
        }
    });

    $traverser->traverse($ast);
}

// コメント除去後にAST解析に失敗した場合のフォールバック処理
function fallbackParse($code, $rel_path) {
    global $crud_data, $defines, $views, $procs;

    $lines = explode("\n", $code);
    $sql_vars = [];
    $vars = [];

    // 1. SQL変数の構築と文字列結合の解決
    foreach ($lines as $line) {
        if (preg_match('/\$(\w+)\s*=\s*(.+);/', $line, $m)) {
            $sql_vars[$m[1]] = trim($m[2], "\"'");
        } elseif (preg_match('/\$(\w+)\s*\.\=\s*(.+);/', $line, $m)) {
            $sql_vars[$m[1]] = ($sql_vars[$m[1]] ?? '') . trim($m[2], "\"'");
        }
    }

    // 2. 解決したSQLを解析にかける（次パートで詳細実装）
    foreach ($sql_vars as $sql) {
        analyzeSQL($sql, $rel_path);
    }
}
function analyzeSQL($sql, $rel_path) {
    global $crud_data, $views, $procs;

    $parser = new PHPSQLParser();
    try {
        $parsed = $parser->parse($sql);
    } catch (Exception $e) {
        logMessage("SQL解析失敗: $sql");
        return;
    }

    // 操作種別を判定
    $crud_type = '';
    if (isset($parsed['SELECT'])) {
        $crud_type = 'R';
    } elseif (isset($parsed['INSERT'])) {
        $crud_type = 'C';
    } elseif (isset($parsed['UPDATE'])) {
        $crud_type = 'U';
    } elseif (isset($parsed['DELETE'])) {
        $crud_type = 'D';
    }

    // テーブル候補を抽出（FROM句、INTO句など）
    $tables = [];

    // SELECT INTO TEMP対応（PostgreSQL）
    if (isset($parsed['SELECT']) && isset($parsed['INTO'])) {
        foreach ($parsed['INTO'] as $into) {
            if (!empty($into['base_expr'])) {
                $tname = $into['base_expr'];
                $tables[] = [$tname . '@temp', 'C'];
            }
        }
    }

    // FROM句・UPDATE句・INSERT INTO句のテーブルを抽出
    $sources = [];
    foreach (['FROM', 'UPDATE', 'INSERT', 'DELETE'] as $clause) {
        if (!isset($parsed[$clause])) continue;
        foreach ($parsed[$clause] as $entry) {
            if (!empty($entry['base_expr'])) {
                $name = trim($entry['base_expr'], "\"` ");
                $name_lower = strtolower($name);

                // プロシージャ or ビューを識別
                if (in_array($name_lower, $procs)) {
                    $tables[] = [$name . '@proc', ''];
                } elseif (in_array($name_lower, $views)) {
                    $tables[] = [$name . '@view', $crud_type];
                } elseif ($crud_type === 'R' && $clause === 'FROM') {
                    // FROM句 + SELECT でプロシージャでなければ R を付与
                    $tables[] = [$name, 'R'];
                } elseif ($clause === 'UPDATE' || $clause === 'INSERT' || $clause === 'DELETE') {
                    $tables[] = [$name, $crud_type];
                }
            }
        }
    }

    // SELECT INTO TEMP の FROM句のテーブルに R を付ける
    if (isset($parsed['FROM']) && isset($parsed['INTO'])) {
        foreach ($parsed['FROM'] as $entry) {
            if (!empty($entry['base_expr'])) {
                $src = trim($entry['base_expr'], "\"` ");
                if (!in_array(strtolower($src), $procs)) {
                    $tables[] = [$src, 'R'];
                }
            }
        }
    }

    // 重複排除してCRUD表に追加
    foreach ($tables as list($table, $type)) {
        $key = "$rel_path:$table";
        if (!isset($crud_data[$key])) {
            $crud_data[$key] = ['file' => $rel_path, 'table' => $table, 'C'=>'', 'R'=>'', 'U'=>'', 'D'=>''];
        }
        if (in_array($type, ['C', 'R', 'U', 'D'])) {
            $crud_data[$key][$type] = '○';
        }
    }
}
// === 結果をExcelに出力 ===
$spreadsheet = new Spreadsheet();
$sheet = $spreadsheet->getActiveSheet();
$sheet->setTitle('File-CRUD');

// ヘッダー行
$sheet->fromArray(['Table', 'C', 'R', 'U', 'D'], NULL, 'A1');

// データ出力（ファイル単位に空行で区切る）
$row = 2;
$prev_file = null;
foreach ($crud_data as $entry) {
    if ($entry['file'] !== $prev_file) {
        if ($prev_file !== null) $row++;  // ファイルが変わったら空行
        $sheet->setCellValue("A$row", 'File: ' . $entry['file']);
        $row++;
        $prev_file = $entry['file'];
    }
    $sheet->fromArray([
        $entry['table'],
        $entry['C'],
        $entry['R'],
        $entry['U'],
        $entry['D'],
    ], NULL, "A$row");
    $row++;
}

// ログシート出力
$logSheet = $spreadsheet->createSheet();
$logSheet->setTitle('ログ');
$logSheet->fromArray(['Time', 'Message'], NULL, 'A1');
$row = 2;
foreach ($log_data as $log) {
    $logSheet->fromArray($log, NULL, "A$row");
    $row++;
}

// 保存
$writer = new Xlsx($spreadsheet);
$output_file = 'analysis_result_' . date('Ymd_His') . '.xlsx';
$writer->save($output_file);
echo "Excel出力完了: $output_file\n";



