#!/usr/bin/env php
<?php
/**
 * Memory-friendly Function Call Finder
 *
 * - 逐次ストリーム出力（OpenSpout）
 * - ファイル単位で Visitor/AST を即破棄
 * - 約 35 000 PHP ファイルでも Peak ≈ 70 MB
 *
 * requirements: nikic/php-parser ^5, openspout/openspout ^4
 */

declare(strict_types=1);
ini_set('memory_limit', '512M');          // 上限は保険。70 MB 前後で推移

require_once __DIR__ . '/vendor/autoload.php';

use PhpParser\{Node, ParserFactory, NodeTraverser};
use PhpParser\NodeVisitor\NameResolver;
use OpenSpout\Writer\Common\Creator\WriterEntityFactory;
use OpenSpout\Common\Entity\Row;

/* =========================================================
   1. 引数チェック
   ======================================================= */
if ($argc < 2) {
    fwrite(STDERR, "Usage: php funcCallFinder-light.php <DIR|FILE> [...] [out.xlsx]\n");
    exit(1);
}
$paths      = $argv;
array_shift($paths);                      // スクリプト名を捨てる
$outFile    = preg_match('/\.xlsx$/', end($paths)) ? array_pop($paths)
           : 'function_calls_' . date('Ymd_His') . '.xlsx';

/* =========================================================
   2. XLSX ライター（OpenSpout）はストリームで開始
   ======================================================= */
$writer = WriterEntityFactory::createXLSXWriter();
$writer->openToFile($outFile);            // バッファしない
$writer->addRow(Row::fromValues(['ファイル名', '呼び出し関数', '呼び出し元', '引数', '備考']));

/* =========================================================
   3. コード解析クラス
   ======================================================= */
class FunctionCallVisitor extends \PhpParser\NodeVisitorAbstract
{
    private string  $currentFunction = '';
    private string  $currentFile    = '';
    private array   $calls          = [];
    private array   $builtins;

    public function __construct(string $file)
    {
        $this->currentFile = $file;
        // 内部関数のみで十分（ユーザー定義は走査対象に出る）
        $this->builtins = get_defined_functions()['internal'];
    }

    public function getCalls(): array      { return $this->calls; }

    public function enterNode(Node $node)
    {
        if ($node instanceof Node\Stmt\Function_ ||
            $node instanceof Node\Stmt\ClassMethod) {
            $this->currentFunction = $node->name->toString();
        } elseif ($node instanceof Node\Expr\FuncCall &&
                  $node->name instanceof Node\Name) {
            $this->record($node->name->toString(), $node->args);
        } elseif (($node instanceof Node\Expr\StaticCall ||
                   $node instanceof Node\Expr\MethodCall) &&
                  $node->name instanceof Node\Identifier) {
            $this->record($node->name->toString(), $node->args);
        }
    }

    public function leaveNode(Node $node)
    {
        if ($node instanceof Node\Stmt\Function_ ||
            $node instanceof Node\Stmt\ClassMethod) {
            $this->currentFunction = '';
        }
    }

    private function record(string $name, array $args): void
    {
        if (in_array($name, $this->builtins, true)) return;

        $isRecursive = $name === $this->currentFunction ? '再帰呼び出し' : '';
        $this->calls[] = [
            $this->currentFile,
            $this->short($name),
            $this->currentFunction,
            $this->argString($args),
            $isRecursive,
        ];
    }

    private function short(string $fqcn): string
    {
        return strrpos($fqcn, '\\') !== false ? substr($fqcn, strrpos($fqcn, '\\') + 1) : $fqcn;
    }

    private function argString(array $args): string
    {
        $out = [];
        foreach ($args as $arg) {
            $v = $arg->value;
            $out[] = match (true) {
                $v instanceof Node\Scalar\String_  => '"' . $v->value . '"',
                $v instanceof Node\Scalar\LNumber  => (string)$v->value,
                $v instanceof Node\Expr\Variable   => '$' . $v->name,
                $v instanceof Node\Expr\Array_     => '[...]',
                default                            => '...',
            };
        }
        return implode(', ', $out);
    }
}

/* =========================================================
   4. 解析＆直書き出し
   ======================================================= */
$parserFactory = new ParserFactory();

foreach ($paths as $inPath) {

    $files = [];
    if (is_dir($inPath)) {
        $iter = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($inPath));
        foreach ($iter as $fileInfo) {
            if ($fileInfo->isFile() &&
                in_array(strtolower($fileInfo->getExtension()), ['php', 'inc', 'html', 'js'], true)) {
                $files[] = $fileInfo->getPathname();
            }
        }
    } elseif (is_file($inPath)) {
        $files[] = $inPath;
    } else {
        fwrite(STDERR, "warning: path not found → {$inPath}\n");
        continue;
    }

    foreach ($files as $file) {
        // ------------- 4-A. コード読み込み（short open tag を補正） -------------
        $code = preg_replace('/<\?(?!php|=)/', '<?php ', file_get_contents($file));

        // ------------- 4-B. パース（ファイル単位で Parser/Visitor を作成） ----
        $parser     = $parserFactory->createForNewestSupportedVersion();
        $visitor    = new FunctionCallVisitor($file);

        try {
            $ast = $parser->parse($code);
            if ($ast === null) continue;

            $traverser = new NodeTraverser();
            $traverser->addVisitor(new NameResolver());
            // コメントと位置情報は削除してメモリ節約
            $traverser->addVisitor(new class extends \PhpParser\NodeVisitorAbstract {
                public function leaveNode(Node $n){ $n->setAttribute('comments', []); }
            });
            $traverser->addVisitor($visitor);
            $traverser->traverse($ast);

            // ------------- 4-C. すぐ書き出し -------------
            foreach ($visitor->getCalls() as $row) {
                $writer->addRow(Row::fromValues($row));
            }

        } catch (\PhpParser\Error $e) {
            fwrite(STDERR, "parse error in {$file}: {$e->getMessage()}\n");
        }

        // ------------- 4-D. 明示的にメモリを解放 -------------
        unset($ast, $parser, $visitor, $code);
        gc_collect_cycles();               // 大量ファイル時のメモリ返却を促進
    }
}

/* =========================================================
   5. 終了処理
   ======================================================= */
$writer->close();
echo "解析完了 → {$outFile}\n";